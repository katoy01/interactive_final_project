/**
 * GLOBAL VARIABLES
 */
let tilesetArtwork, playerArtwork;
let chicken_babyArt, chickenArt, cow_baby_brownArt, cow_brownArt;
// `stage` = different states of the entire game
let stage = 0;
let cnv;
let inventoryCanvas;
let startImage;
let inventoryArtwork;

let inventoryArray = [];
let storeArray = [];
let inventoryTiles = [];
let displayItems = [];
let emotes = [];
let nPCs = [];

let inventoryItems;
let cornSeeds, cornSeeds1;
let wheatSeeds, wheatSeeds1;
let tomatoSeeds, tomatoSeeds1;
let milk;
let eggs;
let corn;
let tomato;
let wheat;
let eggsalad, bruschetta, cheesybread;
let cheesybread_plate, eggsalad_plate, bruschetta_plate;
let pot;
let recipeBookPNG;
let shop_inside;

let dish_pile, dish1, dish2, bowl;
let npc1, npc2, npc3;
let table, chair_right, chair_left;
let door;

let arrow;
let cheesybread_bubble, eggsalad_bubble, bruschetta_bubble;
let eggsalad_menu, bruschetta_menu, cheesybread_menu;
let pot_empty, pot_full;

//emotions 
let amused, angry, annoyed, cool, crying,
    embarrassed, happy, love,
    pleased, relaxed, surprised, tired, unimpressed,
    upset;
var villager_voice1, villager_voice2;
let villager_no, villager_happy;
let good_food, bad_food, get_food, put_food;

let cornSeedsArt, seedsEmpty;
let wheatSeedsArt;
let tomatoSeedsArt;
let milkArt, milkEmpty;
let eggsArt, eggsEmpty;
let cornArt, cornEmpty;
let tomatoArt, tomatoEmpty;
let wheatArt, wheatEmpty;

// selecting inventory when planting seeds
let numInventorySelected = -1;
let numStoreSelected = -1;
let selectedStatus = false;
let selectedStatus1 = false;
let numIngredientSelected = -1;
let ingredientSelected = false;

let gate;
let adultMoo;
let calfMoo;
let adultChicken;
let chicks;
let harvest;
let plop;
let clickSound;
let walk;
let field_theme;
let cookingSound;
let ding;
let scrollFlip;
let disposalSound;
let door_open, door_close;
let bubblePop;

// The size of each tile (32 x 32 square)
// They are all the same now, which might seem redundant, but we were experimenting with tile sizes 
//      and wondered if maybe we want to change it in the future, so we will leave this as is.
let worldTileSize = 32;
let inventoryTileSize = 32;
let playerTileSizeX = 32, playerTileSizeY = 32;
let kitchenTileSize = 80;

// offsets for screen scrolling
let offsetX = -495;
let offsetY = -685;
let minOffsetX, minOffsetY;
let kitchenOffsetX = 0 - (kitchenTileSize * 6 + kitchenTileSize / 2);
let kitchenOffsetY = 0 - (kitchenTileSize * 2 + kitchenTileSize / 2);
let minOffsetXKitchen, minOffsetYKitchen;

// The farm world 
// made with tiles extracted from `/assets/image/global.png`
let world = [
    //                          10                            20                            30                            40                            50                            60                            70                            80
    [13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13],
    //                                           10                                                20                                                 30                                               40                                      50                                       60                                      70                                      80
    [13, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2222, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 2812, 1640, 1640, 1640, 1640, 1640, 1640, 1640, 1640, 1640, 1640, 1640, 1640, 1640, 13],
    [13, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2370, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 2812, 1640, 1640, 1640, 1640, 1640, 1640, 1640, 1640, 1640, 1640, 1640, 1640, 1640, 13],

    [13, 2369, 2521, 2517, 2517, 2517, 2517, 2517, 2517, 2517, 2517, 2517, 2517, 2517, 2517, 2517, 2517, 2517, 2517, 2517, 2517, 2517, 2517, 2517, 2517, 2517, 2517, 2517, 2517, 2517, 2517, 2517, 2517, 2517, 2517, 2517, 2517, 2517, 2517, 2518, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 2812, 3848, 3849, 1640, 1640, 3848, 3849, 1640, 1640, 3848, 3849, 1640, 1640, 1640, 13],
    //                                           10                                                20                                                 30                                             40                                        50                                         60                                          70                                          80
    [13, 2369, 2370, 3850, 3851, 3855, 4782, 4296, 4297, 4297, 4297, 4297, 4297, 4297, 4297, 4297, 4297, 4297, 4297, 4297, 4297, 4297, 4297, 4297, 4297, 4297, 4297, 4297, 4297, 4297, 4297, 4297, 4297, 4297, 4297, 4298, 607, 4005, 4006, 607, 607, 607, 3850, 3851, 607, 607, 607, 607, 607, 607, 607, 4003, 607, 4002, 607, 607, 607, 607, 607, 607, 2630, 2631, 607, 607, 607, 2812, 3996, 3997, 1640, 1640, 3996, 3997, 1640, 1640, 3996, 3997, 1640, 1640, 1640, 13],
    //start row of farm plots 
    //                                         10                                                20                                              30                                            40                                        50                                   60                                            70                                               80
    [13, 2369, 2370, 3998, 3999, 1207, 1059, 4444, 1647, 1651, 1651, 1651, 1651, 1651, 1651, 1651, 1503, 607, 3850, 3851, 607, 607, 1647, 1651, 1651, 1651, 1651, 1651, 1651, 1651, 1651, 1503, 607, 3850, 3851, 607, 607, 1203, 1059, 607, 607, 607, 3998, 3999, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 2778, 2779, 607, 607, 607, 2960, 2961, 2961, 2961, 2961, 2961, 2961, 2961, 2961, 2961, 2961, 2377, 2369, 2369, 13],
    //                                         10                                                20                                              30                                             40                                        50                                            60                                             70                                              80
    [13, 2369, 2370, 3855, 909, 909, 1060, 4444, 1649, 1353, 1353, 1353, 1353, 1353, 1353, 1353, 1504, 607, 3998, 3999, 607, 607, 1649, 1353, 1353, 1353, 1353, 1353, 1353, 1353, 1353, 1504, 607, 3998, 3999, 607, 4152, 1205, 1060, 4152, 607, 607, 607, 607, 607, 607, 607, 3850, 3851, 607, 4151, 607, 607, 1095, 1096, 1097, 1098, 1099, 607, 607, 2778, 2779, 607, 607, 4297, 4297, 4297, 4297, 4297, 4297, 4297, 4297, 4297, 4298, 607, 607, 2812, 2369, 2369, 13],
    //                                         10                                             20                                              30                                             40                                         50                                             60                                               70                                              80
    [13, 2369, 2370, 1205, 909, 909, 1060, 4444, 1649, 1353, 1353, 1353, 1353, 1353, 1353, 1353, 1504, 607, 607, 3850, 3851, 607, 1649, 1353, 1353, 1353, 1353, 1353, 1353, 1353, 1353, 1504, 607, 607, 607, 607, 4152, 1205, 1060, 4152, 607, 607, 607, 607, 4002, 607, 607, 3998, 3999, 607, 607, 607, 607, 1243, 1244, 1245, 1246, 1247, 3072, 3073, 3074, 3075, 3076, 3077, 1207, 1207, 2584, 2585, 2586, 1207, 1207, 1697, 1697, 4446, 607, 607, 2812, 2369, 2369, 13],
    //edge row right above bpttom row of plot 
    //                                         10                                             20                                              30                                               40                                        50                                           60                                               70                                           80
    [13, 2369, 2370, 1205, 909, 909, 1060, 4444, 1649, 1353, 1353, 1353, 1353, 1353, 1353, 1353, 1504, 607, 607, 3998, 3999, 607, 1649, 1353, 1353, 1353, 1353, 1353, 1353, 1353, 1353, 1504, 607, 3850, 3851, 607, 4152, 1205, 1060, 4152, 607, 607, 4152, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 1391, 1392, 1393, 1394, 1395, 3220, 3221, 3222, 3223, 3224, 3225, 908, 908, 2732, 2733, 2734, 2882, 908, 908, 1697, 4446, 607, 607, 2812, 2369, 2369, 13],
    //end row of farm plots 
    //                                         10                                              20                                              30                                               40                                        50                                           60                                               70                                           80
    [13, 2369, 2370, 1205, 909, 909, 1060, 4444, 1501, 1502, 1502, 1502, 1502, 1502, 1502, 1502, 1500, 607, 3850, 3851, 607, 607, 1501, 1502, 1502, 1502, 1502, 1502, 1502, 1502, 1502, 1500, 607, 3998, 3999, 607, 4004, 1205, 1060, 4004, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 1539, 1540, 1541, 1542, 1543, 4593, 3369, 3370, 3371, 3372, 908, 908, 908, 908, 908, 908, 908, 908, 908, 1697, 4446, 607, 607, 2812, 2369, 2369, 13],
    //^10th row
    //                                         10                                               20                                                 30                                                40                                                50                                           60                                               70                                           80
    //end corner row of fence                                     4299 is gate                                                                                                                                               4591 below                                                                                                                      1060 is side dirt
    [13, 2369, 2370, 1205, 909, 909, 1060, 4592, 4593, 4593, 4593, 4593, 4593, 4299, 4593, 4593, 4593, 4593, 3998, 3999, 4593, 4593, 4593, 4593, 4593, 4593, 4299, 4593, 4593, 4593, 4593, 4593, 4593, 4593, 4593, 4593, 4589, 1205, 1060, 4588, 4593, 4593, 4593, 4593, 4593, 4593, 4593, 4593, 4593, 4593, 4593, 4593, 4593, 1687, 1688, 1689, 1690, 1691, 4593, 3517, 3518, 3519, 3520, 908, 908, 908, 908, 908, 908, 908, 908, 908, 1060, 4446, 607, 607, 2812, 2369, 2369, 13],
    //                                                                                                                                                                                                                               1546 below
    //                                         10                                               20                                               30                                              40                                         50                                        60                                      70                                           80
    [13, 2369, 2370, 1205, 909, 909, 1208, 1207, 1207, 1207, 1207, 1207, 1209, 909, 1208, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1209, 909, 1208, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1209, 1198, 1207, 1207, 3854, 3854, 4591, 908, 908, 908, 908, 908, 909, 908, 1398, 1398, 908, 908, 908, 908, 908, 908, 908, 908, 908, 908, 908, 908, 908, 908, 908, 908, 908, 908, 908, 1060, 4446, 607, 607, 2812, 2369, 2369, 13],
    //                                        10                                             20                                             30                                                40                                         50                                      60                                      70                                           80
    [13, 2369, 2370, 1205, 909, 909, 909, 3721, 3721, 3721, 3721, 3721, 909, 909, 909, 3721, 3721, 3721, 3721, 3721, 3721, 3721, 3721, 3721, 3721, 909, 909, 909, 3721, 3721, 3721, 3721, 3721, 3721, 3721, 3721, 3721, 909, 909, 909, 909, 909, 3854, 4591, 1697, 909, 909, 909, 909, 909, 909, 1545, 1546, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 1060, 4446, 607, 607, 2812, 2369, 2369, 13],
    //                                     10                                      20                                      30                                       40                                         50                                      60                                      70                                          80
    [13, 2369, 2370, 1205, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 1060, 4591, 2725, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 1060, 4446, 607, 607, 2812, 2369, 2369, 13],
    //                                     10                                      20                                      30                                       40                                         50                                      60                                      70                                          80
    [13, 2369, 2370, 1205, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 1060, 4591, 2873, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 1060, 4446, 607, 607, 2812, 2369, 2369, 13],
    //                                        10                                               20                                               30                                                40                                         50                                      60                                      70                                           80
    [13, 2369, 2370, 1205, 909, 909, 1062, 1058, 1058, 1058, 1058, 1206, 909, 1062, 1058, 1058, 1058, 1058, 1058, 1058, 1058, 1058, 1058, 1058, 1058, 1206, 909, 1062, 1058, 1058, 1058, 1058, 1058, 1058, 1058, 1058, 1058, 1058, 1206, 909, 909, 909, 1060, 4591, 1205, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 1060, 4446, 607, 607, 2812, 2369, 2369, 13],
    //                                         10                                               20                                                30                                                40                                         50                                      60                                      70                                           80
    [13, 2369, 2370, 1205, 909, 909, 1060, 4296, 4297, 4297, 4297, 4297, 4299, 4297, 4297, 4297, 4297, 4297, 4297, 3850, 3851, 4440, 4297, 4297, 4297, 4441, 4299, 4440, 4297, 4297, 4297, 4297, 4297, 4297, 4297, 4297, 4297, 4298, 1205, 909, 909, 909, 1060, 4591, 2725, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 1060, 4446, 607, 607, 2812, 2369, 2369, 13],
    //                                         10                                               20                                               30                                           40                                         50                                      60                                      70                                           80
    [13, 2369, 2370, 1205, 909, 909, 1060, 4446, 1647, 1651, 1651, 1651, 1651, 1651, 1651, 1651, 1651, 1503, 607, 3998, 3999, 607, 1647, 1651, 1651, 1651, 1651, 1651, 1651, 1651, 1651, 1651, 1503, 607, 607, 607, 607, 4446, 1205, 909, 909, 909, 1060, 4591, 2873, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 1060, 4446, 607, 607, 2812, 2369, 2369, 13],
    //                                         10                                               20                                               30                                           40                                         50                                      60                                      70                                           80    
    [13, 2369, 2370, 1205, 909, 909, 1060, 4446, 1649, 1353, 1353, 1353, 1353, 1353, 1353, 1353, 1353, 1504, 3850, 3851, 607, 607, 1649, 1353, 1353, 1353, 1353, 1353, 1353, 1353, 1353, 1353, 1504, 607, 607, 607, 607, 4446, 1205, 909, 909, 909, 1060, 4591, 1205, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 1060, 4446, 607, 607, 2812, 2369, 2369, 13],
    //                                         10                                               20                                               30                                             40                                         50                                      60                                      70                                           80    
    [13, 2369, 2370, 1205, 909, 909, 1060, 4446, 1649, 1353, 1353, 1353, 1353, 1353, 1353, 1353, 1353, 1504, 3998, 3999, 607, 607, 1649, 1353, 1353, 1353, 1353, 1353, 1353, 1353, 1353, 1353, 1504, 607, 3850, 3851, 607, 4446, 1205, 909, 909, 909, 1060, 4591, 1205, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 1060, 4446, 607, 607, 2812, 2369, 2369, 13],
    //^20th row
    //                                         10                                               20                                            30                                             40                                             50                                                60                                                70                                             80    
    [13, 2369, 2370, 1205, 909, 909, 1060, 4446, 1649, 1353, 1353, 1353, 1353, 1353, 1353, 1353, 1353, 1504, 607, 607, 607, 607, 1649, 1353, 1353, 1353, 1353, 1353, 1353, 1353, 1353, 1353, 1504, 607, 3998, 3999, 607, 4446, 1205, 909, 909, 909, 1060, 4446, 1057, 1058, 1058, 1058, 1058, 1058, 1058, 1058, 1058, 1058, 1206, 1062, 1058, 1058, 1058, 1058, 1058, 1058, 1058, 1058, 1058, 1399, 1400, 1058, 1058, 1058, 1058, 1058, 1056, 4446, 607, 607, 2812, 2369, 2369, 13],
    //                                         10                                               20                                            30                                            40                                             50                                                60                                                70                                            80    
    [13, 2369, 2370, 1205, 909, 909, 1060, 4446, 1649, 1353, 1353, 1353, 1353, 1353, 1353, 1353, 1353, 1504, 607, 607, 607, 607, 1649, 1353, 1353, 1353, 1353, 1353, 1353, 1353, 1353, 1353, 1504, 607, 607, 607, 607, 4446, 1205, 909, 909, 909, 1060, 4592, 4593, 4593, 4593, 4593, 4593, 4593, 4593, 4593, 4593, 4593, 4299, 4299, 4593, 4593, 4593, 4593, 4593, 4593, 4593, 4593, 4593, 4593, 4593, 4593, 4593, 4593, 4593, 4593, 4593, 4594, 607, 607, 2812, 2369, 2369, 13],
    //                                         10                                               20                                            30                                           40                                             50                                                60                                                70                                             80    
    [13, 2369, 2370, 1205, 909, 909, 1060, 4446, 1501, 1502, 1502, 1502, 1502, 1502, 1502, 1502, 1502, 1500, 607, 607, 607, 607, 1501, 1502, 1502, 1502, 1502, 1502, 1502, 1502, 1502, 1502, 1500, 607, 607, 607, 607, 4446, 1205, 909, 909, 909, 1208, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1209, 1208, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1059, 607, 607, 2812, 2369, 2369, 13],
    //                                         10                                                20                                               30                                           40                                        50                                       60                                     70                                           80   
    [13, 2369, 2370, 1205, 909, 909, 1060, 4592, 4593, 4593, 4593, 4593, 4593, 4593, 4593, 4593, 4593, 4593, 4593, 4593, 4593, 4593, 4593, 4593, 4593, 4593, 4593, 4593, 4593, 4593, 4593, 4593, 4593, 4593, 4593, 4593, 4593, 4594, 1205, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 1060, 607, 607, 2812, 2369, 2369, 13],
    //                                       10                                            20                                       30                                      40                                      50                                       60                                     70                                          80   
    [13, 2369, 2370, 1205, 909, 909, 1060, 607, 607, 3014, 3015, 3016, 3017, 3018, 3019, 3020, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 397, 398, 399, 400, 607, 607, 607, 607, 607, 1205, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 1060, 607, 607, 2812, 2369, 2369, 13],
    //                                       10                                             20                                       30                                       40                                              50                                                60                                                70                                             80   
    [13, 2369, 2370, 1205, 909, 909, 1060, 607, 607, 3162, 3163, 3164, 3165, 3166, 3167, 3168, 607, 607, 4004, 607, 607, 607, 607, 607, 607, 607, 607, 607, 544, 545, 546, 547, 548, 607, 607, 607, 607, 607, 1205, 909, 909, 1062, 1058, 1058, 1058, 1058, 1058, 1058, 1058, 1058, 1058, 1058, 1058, 1058, 1058, 1058, 1058, 1058, 1058, 1058, 1058, 1058, 1058, 1058, 1058, 1058, 1058, 1058, 1058, 1058, 1058, 1058, 1058, 1056, 607, 607, 2812, 2369, 2369, 13],
    //                                       10                                             20                                         30                                       40                                          50                                      60                                      70                                         80   
    [13, 2369, 2370, 1205, 909, 909, 1060, 6958, 607, 3310, 3311, 3312, 3313, 3314, 3315, 3316, 607, 607, 607, 607, 607, 3850, 3851, 607, 607, 607, 607, 4004, 692, 693, 694, 695, 696, 607, 607, 607, 607, 607, 1205, 909, 909, 1060, 607, 3850, 3851, 607, 4003, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 2812, 2369, 2369, 13],
    //                                       10                                              20                                         30                                      40                                          50                                            60                                                70                                           80   
    [13, 2369, 2370, 1205, 909, 909, 1060, 7106, 607, 3458, 3459, 3460, 3461, 3462, 3463, 3464, 607, 607, 4003, 607, 607, 3998, 3999, 607, 607, 607, 607, 607, 840, 841, 842, 843, 844, 607, 607, 607, 607, 607, 1205, 909, 909, 1060, 607, 3998, 3999, 607, 607, 607, 607, 607, 607, 607, 1802, 2087, 2087, 2087, 2087, 2087, 2087, 2087, 2087, 2087, 2087, 2087, 2087, 2087, 2087, 2087, 2087, 2087, 2087, 1946, 607, 607, 607, 607, 2812, 2369, 2369, 13],
    //                                        10                                              20                                         30                                    40                                          50                                            60                                                70                                           80   
    [13, 2369, 2370, 1205, 909, 909, 1060, 7254, 3857, 3606, 3607, 3608, 3609, 3610, 3611, 3612, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 988, 989, 990, 991, 992, 607, 607, 607, 4003, 607, 1205, 909, 909, 1060, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 1800, 1936, 1936, 1936, 1936, 1936, 1936, 1936, 1936, 1936, 1936, 1936, 1936, 1936, 1936, 1936, 1936, 1936, 1936, 1945, 607, 607, 607, 607, 2812, 2369, 2369, 13],
    //                                               10                                                  20                                                30                                                  40                                                 50                                                      60                                                           70                                                     80    
    [13, 2369, 2370, 1205, 909, 909, 1060, 607, 607, 607, 607, 1205, 909, 1060, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 1205, 909, 1060, 607, 607, 607, 607, 607, 607, 1205, 909, 909, 1060, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 1800, 1936, 1936, 1936, 1936, 1936, 1943, 1947, 1947, 1947, 1947, 1947, 1799, 1936, 1936, 1936, 1936, 1936, 1936, 1945, 607, 607, 607, 607, 2812, 2369, 2369, 13],
    //^30th row 
    //                                                  10                                                         20                                                          30                                                         40                                                 50                                                        60                                                          70                                                       80    
    [13, 2369, 2370, 1205, 909, 909, 1208, 1207, 1207, 1207, 1207, 1209, 909, 1208, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1209, 909, 1208, 1207, 1207, 1207, 1207, 1207, 1207, 1209, 909, 909, 1060, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 1800, 1936, 1936, 1936, 1936, 1936, 1945, 1874, 1875, 1876, 1877, 1878, 1800, 1936, 1936, 1936, 1936, 1936, 1936, 1945, 607, 3850, 3851, 607, 2812, 2369, 2369, 13],
    //                                              10                                                20                                                30                                                 40                                                  50                                                       60                                                          70                                                      80    
    [13, 2369, 2370, 1205, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 1060, 6958, 607, 607, 607, 607, 607, 607, 607, 607, 607, 1800, 1936, 1936, 1936, 1936, 1936, 1945, 2022, 2023, 2024, 2025, 2026, 1800, 1936, 1936, 1936, 1936, 1936, 1936, 1945, 607, 3998, 3999, 607, 2812, 2369, 2369, 13],
    //                                               10                                                 20                                               30                                                40                                                   50                                                        60                                                70                                           80    
    [13, 2369, 2370, 1205, 6958, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 909, 1060, 7106, 607, 607, 607, 607, 4782, 607, 607, 607, 607, 1800, 1936, 1936, 1936, 1936, 1936, 1945, 2170, 2171, 2172, 2173, 2174, 1800, 1936, 2226, 1936, 1936, 1936, 1936, 1945, 607, 607, 607, 607, 2812, 2369, 2369, 13],
    //                                                    10                                                          20                                                          30                                                          40                                                   50                                                       60                                                70                                           80    
    [13, 2369, 2370, 4155, 7106, 1058, 1058, 1058, 1058, 1058, 1058, 1058, 1058, 1058, 1058, 1058, 1058, 1058, 1058, 1058, 1058, 1058, 1058, 1058, 1058, 1058, 1058, 1058, 1058, 1058, 1058, 1058, 1058, 1058, 1058, 1058, 1058, 1058, 1058, 1058, 1058, 607, 7254, 607, 607, 607, 607, 607, 607, 607, 607, 607, 1800, 1936, 1936, 1936, 1936, 1936, 1945, 2318, 2319, 2320, 2321, 2322, 1800, 1936, 1936, 1936, 1936, 1936, 1936, 1945, 607, 4004, 607, 607, 2812, 2369, 2369, 13],
    //                                                10                                          20                                      30                                      40                                      50                                              60                                                70                                           80    
    [13, 2369, 2370, 3856, 7254, 3856, 607, 607, 607, 3850, 3851, 607, 607, 607, 607, 607, 3850, 3851, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 1800, 1936, 1936, 1936, 1936, 1936, 1945, 2466, 2467, 2468, 2469, 2470, 1800, 1936, 1936, 1929, 1947, 1947, 1947, 1949, 607, 607, 607, 607, 2812, 2369, 2369, 13],
    //                                       10                                          20                                      30                                      40                                      50                                             60                                               70                     plain grass               80    
    [13, 2369, 2369, 2371, 2222, 4155, 607, 607, 607, 3998, 3999, 607, 607, 607, 607, 607, 3998, 3999, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 1948, 1936, 1936, 1936, 1936, 1936, 1797, 1798, 1946, 1939, 1802, 1798, 1796, 1936, 1936, 1945, 607, 607, 607, 607, 607, 607, 607, 607, 2368, 2369, 2369, 13],
    //                                          10                                                20                                                30                                                40                                             50                                            60                                               70                                               80    
    [13, 2369, 2369, 2369, 2369, 2376, 3850, 3851, 2376, 2376, 2376, 2376, 2376, 3850, 3851, 2376, 2376, 2376, 2376, 2376, 2376, 3850, 3851, 2376, 2376, 2376, 2376, 2376, 2376, 2376, 2376, 2376, 2376, 2376, 2376, 2376, 2376, 2376, 2376, 2376, 2376, 2376, 2376, 2376, 2376, 2222, 607, 607, 607, 607, 607, 607, 607, 1948, 1936, 1936, 1936, 1936, 1936, 1936, 1945, 1939, 1800, 1936, 1936, 1936, 1936, 1945, 607, 607, 2220, 2221, 2221, 2221, 2221, 2221, 2369, 2369, 2369, 13],
    //                                          10                                                20                                                30                                                40                                             50                                            60                                               70                                               80    
    [13, 2369, 2369, 2369, 2369, 2369, 3998, 3999, 2369, 2369, 2369, 2369, 2369, 3998, 3999, 2369, 2369, 4155, 2369, 2369, 2369, 3998, 3999, 2369, 4155, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2370, 607, 607, 607, 607, 4003, 607, 607, 607, 1948, 1947, 1947, 1947, 1947, 1947, 1949, 1939, 1948, 1947, 1947, 1947, 1947, 1949, 607, 607, 2368, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 13],
    //                                          10                                                20                                                30                                                40                                             50                                            60                                               70                                               80    
    [13, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2370, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 607, 2368, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 2369, 13],
    [13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13],
    //^40th row
]

// 18 x 9
// 512 x 256
let kitchen = [
    [50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50],
    [50, 47, 48, 47, 48, 47, 48, 47, 48, 47, 48, 47, 48, 47, 48, 47, 48, 50],
    [50, 54, 55, 54, 55, 54, 55, 54, 55, 0, 17, 0, 1, 30, 30, 30, 16, 50],
    [50, 11, 12, 12, 12, 12, 12, 12, 12, 7, 24, 37, 8, 37, 37, 37, 23, 50],
    [50, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 3, 50],
    [50, 11, -2, -4, -3, 12, 12, -2, -4, -3, 12, 12, 12, 12, 12, 12, 10, 50],
    [50, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 50],
    [50, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 50],
    [50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50],
]


let worldNotSolid = [];

for (let y = 4; y < world.length - 4; y++) {
    for (let x = 4; x < world[0].length - 4; x++) {
        if (!isSolid(world[y][x])) {
            worldNotSolid.push([x, y]);
        }
    }
}

// Overlay for the world
let overlay = [];
let overlayKitchen = [];

let player;
let plantArr = [];
let cow, cowBaby, chicken, chickenBaby;
let customerArr = [];
let npcArr = [];
let animalArr = [];

// Stores information for all the plants
let plantInfoAll = {
    'wheat': {
        bagId: 6379,
        sproutArr: [6380, 6381, 6382, 6383, 6384],
        harvestableId: 6385,
        inventoryId: 5969
    },
    'tomato': {
        bagId: 5195,
        sproutArr: [5196, 5197, 5198, 5199, 5200],
        harvestableId: 5201,
        inventoryId: 5961
    },
    'corn': {
        bagId: 5639,
        sproutArr: [5640, 5641, 5642, 5643, 5644],
        harvestableId: 5645,
        inventoryId: 5964
    }
}

// Stores information for all the animals
let animalInfoAll = {
    'cow': {
        img: cow_brownArt,
        tileSize: 48
    },
    'cowBaby': {
        img: cow_brownArt,
        tileSize: 42
    },
    'chicken': {
        img: chickenArt,
        tileSize: 32
    },
    'chickenBaby': {
        img: chicken_babyArt,
        tileSize: 32
    }
}

// Stores information for all NPCs
let npcInfoAll = [
    {
        tileSizeX: 32,
        tileSizeY: 32,
        tilesPerRow: 3,
    },
    {
        tileSizeX: 23,
        tileSizeY: 32,
        tilesPerRow: 6,
    },
    {
        tileSizeX: 32,
        tileSizeY: 32,
        tilesPerRow: 3,
    },
];


/**
 * p5 FUNCTIONS
 */

// Load images and sounds
function preload() {
    tilesetArtwork = loadImage('./assets/image/global.png');
    inventoryArtwork = loadImage('./assets/image/global.png');

    playerArtwork = loadImage('./assets/image/player.png');
    chicken_babyArt = loadImage('./assets/image/chicken_baby.png');
    chickenArt = loadImage('./assets/image/chicken.png');
    cow_baby_brownArt = loadImage('./assets/image/cow_baby_brown.png');
    cow_brownArt = loadImage('./assets/image/cow_brown.png');

    startImage = loadImage("./assets/image/startScreen.jpg");
    inventoryCanvas = loadImage("./assets/image/inventory.png");

    inventoryTiles[0] = loadImage('./assets/image/tomatoseeds.png');
    inventoryTiles[1] = loadImage('./assets/image/wheatseeds.png');
    inventoryTiles[2] = loadImage('./assets/image/cornseeds.png');
    inventoryTiles[3] = loadImage('./assets/image/tomato.png');
    inventoryTiles[4] = loadImage('./assets/image/wheat.png');
    inventoryTiles[5] = loadImage('./assets/image/corn.png');
    inventoryTiles[6] = loadImage('./assets/image/milk.png');
    inventoryTiles[7] = loadImage('./assets/image/egg.png');

    gate = loadSound("./assets/sound/gate.wav");
    calfMoo = loadSound("./assets/sound/babymoo.wav");
    adultMoo = loadSound("./assets/sound/adultmoo.wav");
    harvest = loadSound("./assets/sound/harvest_crop.ogg");
    walk = loadSound("./assets/sound/walk.wav");
    plop = loadSound("./assets/sound/seed_plant.ogg");
    adultChicken = loadSound("./assets/sound/chicken.wav");
    chicks = loadSound("./assets/sound/chicks.wav");
    clickSound = loadSound("./assets/sound/click.wav");
    field_theme = loadSound('./assets/sound/field_theme.wav');
    cookingSound = loadSound('./assets/sound/cookingSound.wav');
    ding = loadSound('./assets/sound/ding.wav');
    scrollFlip = loadSound('./assets/sound/scroll.wav');
    disposalSound = loadSound('./assets/sound/disposal.wav');
    purchase = loadSound('./assets/sound/purchase.wav');
    door_close = loadSound('./assets/sound/door_close.wav');
    door_open = loadSound('./assets/sound/door_open.wav');
    bubblePop = loadSound('./assets/sound/bubblePop.wav');
    villager_voice1 = loadSound('./assets/sound/villager_howl.wav');
    villager_voice2 = loadSound('./assets/sound/villager_sneeze.wav');
    villager_no = loadSound('./assets/sound/villager_no.wav');
    villager_happy = loadSound('./assets/sound/villager_happy.wav');
    good_food = loadSound('./assets/sound/good_food.wav');
    bad_food = loadSound('./assets/sound/bad_food.mp3');
    get_food = loadSound('./assets/sound/get_food.mp3');
    put_food = loadSound('./assets/sound/put_food.wav');

    emotes[0] = loadImage('./assets/image/emotions/love.png');
    emotes[1] = loadImage('./assets/image/emotions/happy.png');
    emotes[2] = loadImage('./assets/image/emotions/pleased.png');
    emotes[3] = loadImage('./assets/image/emotions/relaxed.png');
    emotes[4] = loadImage('./assets/image/emotions/amused.png');
    emotes[5] = loadImage('./assets/image/emotions/embarrassed.png');
    emotes[6] = loadImage('./assets/image/emotions/cool.png');
    emotes[7] = loadImage('./assets/image/emotions/angry.png');
    emotes[8] = loadImage('./assets/image/emotions/annoyed.png');
    emotes[9] = loadImage('./assets/image/emotions/crying.png');
    emotes[10] = loadImage('./assets/image/emotions/surprised.png');
    emotes[11] = loadImage('./assets/image/emotions/tired.png');
    emotes[12] = loadImage('./assets/image/emotions/unimpressed.png');
    emotes[13] = loadImage('./assets/image/emotions/upset.png');

    kitchenArtWork = loadImage('./assets/image/kitchen.png');

    nPCs[0] = loadImage('./assets/image/npc1.png');
    nPCs[1] = loadImage('./assets/image/npc2.png');
    nPCs[2] = loadImage('./assets/image/npc3.png');
    dish_pile = loadImage('./assets/image/dish_pile.png');
    dish1 = loadImage('./assets/image/dish1.png');
    dish2 = loadImage('./assets/image/dish2.png');
    bowl = loadImage('./assets/image/bowl.png');
    npc1 = loadImage('./assets/image/npc1.png');
    npc2 = loadImage('./assets/image/npc2.png');
    npc3 = loadImage('./assets/image/npc3.png');
    table = loadImage('./assets/image/table.png');
    chair_right = loadImage('./assets/image/chair1.png');
    chair_left = loadImage('./assets/image/chair2.png');
    arrow = loadImage('./assets/image/arrow.png');

    eggsalad = loadImage('./assets/image/eggsalad.png');
    bruschetta = loadImage('./assets/image/bruschetta.png');
    cheesybread = loadImage('./assets/image/cheesybread.png');

    eggsalad_plate = loadImage('./assets/image/eggsalad_plate.png');
    bruschetta_plate = loadImage('./assets/image/bruschetta_plate.png');
    cheesybread_plate = loadImage('./assets/image/cheesybread_plate.png');

    eggsalad_bubble = loadImage('./assets/image/bubble_eggsalad.png');
    bruschetta_bubble = loadImage('./assets/image/bubble_bruschetta.png');
    cheesybread_bubble = loadImage('./assets/image/bubble_cheesybread.png');

    eggsalad_menu = loadImage('./assets/image/1_eggsaladmenu.png');
    bruschetta_menu = loadImage('./assets/image/2_bruschettamenu.png');
    cheesybread_menu = loadImage('./assets/image/3_cheesybreadmenu.png');

    pot_empty = loadImage('./assets/image/pot_empty.png');
    pot_full = loadImage('./assets/image/pot_full.png');

    recipeBookPNG = loadImage('./assets/image/recipebook.png');
    fridge = loadImage('./assets/image/fridge_flipped.png');
    door = loadImage('./assets/image/kitchendoor.png');

    shop_inside = loadImage('./assets/image/shop_inside.jpg');
}

// Create canvas, build world and overlay,
// create player, create animals
function setup() {
    field_theme.loop();
    cnv = createCanvas(960, 480);
    background(255);
    cnv.parent('gameCanvas');
    // cellWidth = width/columns;
    // cellHeight = height / 4;

    stroke(0);
    strokeWeight(1);

    // inventory = createGraphics(cnv.parent.width, cnv.parent.height)
    rows = 1;
    cols = 8;

    noiseLocationX = random(1000);

    tilesetArtwork.resize(4736, 2272);
    //inventoryCanvas.resize(960, 480);
    playerArtwork.resize(128, 128);
    chicken_babyArt.resize(128, 160);
    chickenArt.resize(128, 160);
    cow_baby_brownArt.resize(168, 210);
    cow_brownArt.resize(192, 240);

    for (let i of inventoryTiles) {
        i.resize(inventoryTileSize, inventoryTileSize);
    }
    for (let i of emotes) {
        i.resize(230, 200);
    }
    for (let i of nPCs) {
        i.resize(96, 128);
    }
    nPCs[1].resize(138, 128);

    // kitchenTileSize = height / kitchen.length;
    // kitchenTileSize = 80
    // kitchenArtWork.resize(kitchenTileSize * 7, kitchenTileSize * 8);
    // kitchenArtWork.resize(420, 480);

    animalInfoAll['cow'].img = cow_brownArt;
    animalInfoAll['cowBaby'].img = cow_baby_brownArt;
    animalInfoAll['chicken'].img = chickenArt;
    animalInfoAll['chickenBaby'].img = chicken_babyArt;

    // setup the world overlay
    setupOverlay();
    pot = new Pot(0, 0);
    setupOverlayKitchen();

    minOffsetX = (width) - (world[0].length * worldTileSize);
    minOffsetY = (height) - (world.length * worldTileSize);

    minOffsetXKitchen = (width) - (kitchen[0].length * kitchenTileSize);
    minOffsetYKitchen = (height) - (kitchen.length * kitchenTileSize);

    // create our player
    player = new Player(width / 2, height / 2);

    cow = new Animal(52, 15, 'cow');
    cowBaby = new Animal(54, 15, 'cowBaby');
    chicken = new Animal(66, 13, 'chicken');
    chickenBaby = new Animal(68, 15, 'chickenBaby');
    animalArr.push(cow, cowBaby, chicken, chickenBaby);

    for (let i = 0; i < 5; i++) {
        let from = worldNotSolid[floor(random(worldNotSolid.length))];
        let to = worldNotSolid[floor(random(worldNotSolid.length))];
        let npc = new NPC(from[0], from[1], to[0], to[1], worldTileSize, worldTileSize, 1);
        npcArr.push(npc);
    }

    // Stores all the items in inventory
    inventoryArray = [
        tomatoSeeds = new Item("Tomato Seeds", 10, inventoryTiles[0]),
        wheatSeeds = new Item("Wheat Seeds", 10, inventoryTiles[1]),
        cornSeeds = new Item("Corn Seeds", 10, inventoryTiles[2]),
        tomato = new Item("Tomato", 5, inventoryTiles[3]),
        wheat = new Item("Wheat", 5, inventoryTiles[4]),
        corn = new Item("Corn", 5, inventoryTiles[5]),
        milk = new Item("Milk", 5, inventoryTiles[6]),
        eggs = new Item("Eggs", 5, inventoryTiles[7])
    ];
    storeArray = [
        tomatoSeeds1 = new Item1("Tomato Seeds", 500, inventoryTiles[0]),
        wheatSeeds1 = new Item1("Wheat Seeds", 500, inventoryTiles[1]),
        cornSeeds1 = new Item1("Corn Seeds", 500, inventoryTiles[2]),
    ];
}

// Triggers when you click mouse to start game and 
// when you are planting a seed
function mouseClicked() {
    if (stage === 0) {
        stage = 1;
        clickSound.play();
    }
    else if (stage === 2 && selectedStatus === true) {
        player.changeEnvironment();
        stage = 1;
        selectedStatus = false;
        numInventorySelected = -1;
    }
    else if (stage === 3) {
        // cooking = true;
        if (pot.insidePotArr.length > 0 && pot.cooking === 0 && potPopUp) {
            pot.startCooking();
        }
        else if (menuPopUp) {
            if (mouseX > width / 2 && menuShowing < pot.recipeBook.length - 1) {
                menuShowing++;
                scrollFlip.play();
            } else if (mouseX < width / 2 && menuShowing > 0) {
                menuShowing--;
                scrollFlip.play();
            }
        }
    }



}

// Triggers when you press `enter` key when you are in the game,
// or when you press numbers 1-7, or `esc` key when you are in inventory screen
function keyPressed() {
    if (keyCode === 13 && stage === 1) {
        player.changeEnvironment();
    }
    else if (stage === 2) {
        if (keyCode >= 49 && keyCode <= 56) {
            selectedStatus = true;
            numInventorySelected = keyCode - 49;
        }
        else if (keyCode === 27) {
            selectedStatus = false;
            numInventorySelected = -1;
            stage = 1;
        }
    }
    else if (stage === 3) {
        if (keyCode === 13) {
            player.changeEnvironment();
            if (floor((player.x - kitchenOffsetX) / kitchenTileSize) === 12
                && floor((player.y - kitchenOffsetY) / kitchenTileSize) === 7) {
                changeStage();
            }
        }
        else if (keyCode >= 49 && keyCode <= 56) {
            ingredientSelected = true;
            numIngredientSelected = keyCode - 46;
        }
        else if (keyCode === 27) {
            potPopUp = false;
            menuPopUp = false;
            pot.insidePotArr = [];
            ingredientSelected = false;

        } else if (keyCode === 8) {
            pot.insidePotArr.splice(-1, 1);
        }
    }
    else if (stage === 4) {
        if (keyCode >= 49 && keyCode <= 51) {
            selectedStatus1 = true;
            numStoreSelected = keyCode - 49;
            storeArray[numStoreSelected].amount++;
        }
        else if (keyCode === 27) {
            selectedStatus1 = false;
            numStoreSelected = -1;
            stage = 1;
            door_close.play();
        }
        else if (keyCode == 13 && selectedStatus1 == true) {
            inventoryArray[numStoreSelected].amount++;
            purchase.play();

        }
    }
}

function changeStage() {
    if (stage === 1) {
        stage = 3;
        player.y = height - (kitchenTileSize * 1.5);
        kitchenOffsetX = 0 - (kitchenTileSize * 6 + kitchenTileSize / 2);
        kitchenOffsetY = 0 - (kitchenTileSize * 2 + kitchenTileSize);
        player.direction = 3;
        door_open.play();
    } else if (stage === 3) {
        player.x = 480;
        player.y = 340;
        stage = 1;
        player.direction = 0;
        door_close.play();
    }
}
function changeStage1() {
    if (stage === 1) {
        stage = 4;
        door_open.play();
    } else if (stage === 4) {
        player.x = 480;
        player.y = 340;
        stage = 1;
        player.direction = 0;
        door_close.play();
    }
}


// Has start screen (stage = 0), game screen (stage = 1), and inventory screen (stage = 2) and kitchen (stage = 3) and shop (stage = 4)
// Displays world, overlay, player, animals, and any plants that were planted and are growing
function draw() {

    if (stage === 0) {
        background(113, 143, 63);
        image(startImage, 0, 0, 960, 480);
    }

    if (stage === 1) {
        background(113, 143, 63);
        push();
        translate(offsetX, offsetY);
        drawWorld();
        pop();

        // the character will always be drawn in the middle of the screen
        plantArr.forEach(plant => {
            plant.display();
        });
        animalArr.forEach(animal => {
            animal.moveAndDisplay();
            animal.displayEmote();
        })
        npcArr.forEach(npc => {
            npc.display();
        })
        player.moveAndDisplay(playerTileSizeX, playerTileSizeY);
        npcArr.forEach(npc => {
            npc.displayEmote();
            if (npc.isAtEnd()) {
                npc.newDest();
            } else if (npc.walking) {
                npc.move();
            }
        })
        displayTime();
        showProduceInventory();
    }


    if (stage === 2) {
        background(113, 143, 63);
        inventoryBuffer = createGraphics(660, 330);
        inventoryBuffer.image(inventoryCanvas, 0, 0);
        image(inventoryBuffer, 0, 0);
        displaySelectedBox(numInventorySelected);
        textAlign(CENTER);
        fill(0);
        textSize(15);
        if (selectedStatus == true) {
            if (numInventorySelected >= 0 && numInventorySelected <= 7) {
                text("You selected " + inventoryArray[numInventorySelected].name + " You have " + inventoryArray[numInventorySelected].amount + " left", width - width / 5, height / 4 + 25);
                text("Click To Continue", width - width / 5, height / 4 + 50);
                text("Press `esc` to go back", width - width / 5, height / 4 + 75);
            }
        } else {
            text("Please enter what number you want to use", width - width / 5, height / 4 + 25);
            text("Press `esc` to go back", width - width / 5, height / 4 + 50);
        }
        fill(255);
    }

    if (stage === 3) {
        background(113, 143, 63);
        push();
        translate(kitchenOffsetX, kitchenOffsetY);
        drawKitchen();
        pot.display();
        pop();

        player.tileSize = kitchenTileSize;

        if (random(600) < 1 && customerArr.length < 2) {
            if (!(floor((player.x - kitchenOffsetX) / kitchenTileSize) === 12
                && floor((player.y - kitchenOffsetY) / kitchenTileSize) === 7)) {
                newCustomer();
            }
        }
        customerArr.forEach(customer => {
            customer.displayKitchen();
        })
        player.moveAndDisplayKitchen();
        customerArr.forEach(customer => {
            customer.displayEmote();
            if (customer.isAtEnd()) {
                if (customer.order >= 0) {
                    customer.goHome();
                    customer.walking = false;
                    customer.ordering = true;
                } else {
                    removeCustomer(customer.id);
                }
            } else if (customer.walking) {
                customer.move();
            }
        })

        if (potPopUp) {
            showIngredients();
        }
        if (menuPopUp) {
            showMenu();
        }

        // imageMode(CORNER);
        // image(kitchenArtWork, 0, 0);
        // let imgID = 0;
        // for (let y = 0; y < kitchenArtWork.height / worldTileSize; y++) {
        //     for (let x = 0; x < kitchenArtWork.width / worldTileSize; x++) {
        //         textAlign(CENTER);
        //         text(imgID, x * worldTileSize + worldTileSize / 2, y * worldTileSize + worldTileSize / 2);
        //         imgID++;
        //     }
        // }
    }
    if (stage === 4) {
        background(113, 143, 63);
        image(shop_inside, 0, 0, 960, 480);
        displaySelectedBox1(numStoreSelected);
        textAlign(CENTER);
        fill(0);
        textSize(15);
        if (selectedStatus1 == true) {
            if (numStoreSelected >= 0 && numStoreSelected <= 3) {
                text("You selected: " + storeArray[numStoreSelected].name, 197, height / 6 - 15);
                text("Press enter to buy item", 196, height / 6 + 15);
                text("Press `esc` to go back", 196, height / 6 + 35);
            }
        } else {
            text("Please enter what number", 197, height / 6 - 15);
            text("you want to select", 198, height / 6 + 10);
            text("Press `esc` to leave", 199, height / 6 + +35);
        }
        //fill(255);
    }
}


/**
 * HELPER FUNCTIONS
 */

// Draw the entire world using the 2D array above
function drawWorld() {
    for (let y = 0; y < world.length; y++) {
        for (let x = 0; x < world[y].length; x++) {
            // extract the tile here
            let id = world[y][x];
            drawTile(tilesetArtwork, id, worldTileSize, worldTileSize,
                x * worldTileSize, y * worldTileSize, worldTileSize, worldTileSize);

            // if (!isSolid(id)) {
            //     textAlign(CENTER);
            //     textSize(10);
            //     text(id, x * worldTileSize + worldTileSize / 2, y * worldTileSize + worldTileSize / 2)
            //     if (isSolid(world[y - 1][x]) && isSolid(world[y + 1][x])
            //         && isSolid(world[y][x + 1]) && isSolid(world[y][x - 1])) {
            //         console.log(id);
            //     }
            // }

            // also draw the overlay here
            let idOverlay = overlay[y][x];
            drawTile(tilesetArtwork, idOverlay, worldTileSize, worldTileSize,
                x * worldTileSize, y * worldTileSize, worldTileSize, worldTileSize);
        }
    }
}

function drawKitchen() {
    for (let y = 0; y < kitchen.length; y++) {
        for (let x = 0; x < kitchen[y].length; x++) {
            // extract the tile here
            let id = kitchen[y][x];
            drawTile(kitchenArtWork, id, worldTileSize, worldTileSize,
                x * kitchenTileSize, y * kitchenTileSize, kitchenTileSize, kitchenTileSize);

            // also draw the overlay here
            let idOverlay = overlayKitchen[y][x];
            // flip the fridge
            if (idOverlay === 3 || idOverlay === 10) {
                if (idOverlay === 10) {
                    drawTile(fridge, 0, fridge.width, fridge.height,
                        x * kitchenTileSize, (y - 1) * kitchenTileSize, kitchenTileSize, kitchenTileSize * 2);
                }
            } else {
                drawTile(kitchenArtWork, idOverlay, worldTileSize, worldTileSize,
                    x * kitchenTileSize, y * kitchenTileSize, kitchenTileSize, kitchenTileSize);
            }
            // draw book on counter
            if (idOverlay === 7) {
                drawTile(recipeBookPNG, 0, recipeBookPNG.width, recipeBookPNG.height,
                    x * kitchenTileSize, y * kitchenTileSize - kitchenTileSize * (3 / 4), kitchenTileSize, kitchenTileSize);
            }
            // draw door
            if (x === 12 && y === 8) {
                imageMode(CENTER);
                drawTile(door, 0, door.width, door.height, x * kitchenTileSize + kitchenTileSize / 2,
                    y * kitchenTileSize + kitchenTileSize / 2, kitchenTileSize * 3, kitchenTileSize * 2);
                imageMode(CORNER);
            }
            // draw table
            if (idOverlay === -4) {
                drawTile(table, 0, table.width, table.height,
                    x * kitchenTileSize, y * kitchenTileSize, kitchenTileSize, kitchenTileSize);
            }
            if (idOverlay === -2) {
                drawTile(chair_right, 0, chair_right.width, chair_right.height,
                    x * kitchenTileSize, y * kitchenTileSize, kitchenTileSize, kitchenTileSize);
            }
            if (idOverlay === -3) {
                drawTile(chair_left, 0, chair_left.width, chair_left.height,
                    x * kitchenTileSize, y * kitchenTileSize, kitchenTileSize, kitchenTileSize);
            }
            // textAlign(CENTER);
            // textSize(10);
            // text(x + ',' + y, x * kitchenTileSize + kitchenTileSize / 2, y * kitchenTileSize + kitchenTileSize / 2)
        }
    }
}

// Draw tile with size `tileSizeX`, `tileSizeY` with an ID of `id` 
// extracted from the image `img`, at screen position `screenX`, `screenY`
function drawTile(img, id, tileSizeX, tileSizeY, screenX, screenY, displayX, displayY) {
    // step 1: figure out how many tiles are on each row of our image
    let tilesPerRow = int(img.width / tileSizeX);

    // step 2: give the tile ID, figure out where that tile exists
    // in the source image.
    let imageX = int(id % tilesPerRow) * tileSizeX;
    let imageY = int(id / tilesPerRow) * tileSizeY;

    // step 3: draw the desired tile
    image(img, screenX, screenY, displayX, displayY,
        imageX, imageY, tileSizeX, tileSizeY,);
}

// Setup our overlay array
function setupOverlay() {
    // set up the overlay to be the same size as the world, just filled with -1's
    for (let y = 0; y < world.length; y++) {
        overlay.push([]);
        for (let x = 0; x < world[y].length; x++) {
            // adds Gates to our overlay, and deletes it from the world array
            // so that it's interactable/ changable
            if (world[y][x] === 4299) {
                overlay[y].push(4299);
                world[y][x] = 607;
            } else {
                overlay[y].push(-1);
            }
        }
    }
}

function setupOverlayKitchen() {
    // set up the overlay to be the same size as the world, just filled with -1's
    for (let y = 0; y < kitchen.length; y++) {
        overlayKitchen.push([]);
        for (let x = 0; x < kitchen[y].length; x++) {
            // add pot
            if (kitchen[y][x] === 17) {
                pot.change(x * kitchenTileSize - kitchenTileSize * 0.1, y * kitchenTileSize + kitchenTileSize * 0.1);
            }
            // add furniture to overlay, add tiles and walls to kitchen
            if (y === 2 && (x >= kitchen[y].length - 9 && x <= kitchen[y].length - 2)) {
                overlayKitchen[y].push(kitchen[y][x]);
                kitchen[y][x] = 55 - (x % 2);
            }
            else if (y === 3 && (x >= kitchen[y].length - 9 && x <= kitchen[y].length - 3)) {
                overlayKitchen[y].push(kitchen[y][x]);
                kitchen[y][x] = 12;
            }
            else if ((y >= 3 && y <= 5) && (x === kitchen[y].length - 2)) {
                overlayKitchen[y].push(kitchen[y][x]);
                kitchen[y][x] = 13;
            }
            else if (kitchen[y][x] < 0) {
                overlayKitchen[y].push(kitchen[y][x]);
                kitchen[y][x] = 12;
            }
            else {
                overlayKitchen[y].push(-1);
            }
        }
    }
}

// Obtain the world tile ID at a given screen coordinate
function getWorldTileAtPosition(screenX, screenY) {
    let id;
    if (stage === 3) {
        // convert screen coordinates into array coordinates
        let arrayX = int((screenX - kitchenOffsetX) / kitchenTileSize);
        let arrayY = int((screenY - kitchenOffsetY) / kitchenTileSize);

        id = kitchen[arrayY][arrayX];
    } else {
        // convert screen coordinates into array coordinates
        let arrayX = int((screenX - offsetX) / worldTileSize);
        let arrayY = int((screenY - offsetY) / worldTileSize);

        id = world[arrayY][arrayX];
    }
    return id;
}

// Obtain the overlay tile ID at a given screen coordinate
function getOverlayTileAtPosition(screenX, screenY) {
    let id;
    if (stage === 3) {
        // convert screen coordinates into array coordinates
        let arrayX = int((screenX - kitchenOffsetX) / kitchenTileSize);
        let arrayY = int((screenY - kitchenOffsetY) / kitchenTileSize);

        id = overlayKitchen[arrayY][arrayX];
    } else {
        // convert screen coordinates into array coordinates
        let arrayX = int((screenX - offsetX) / worldTileSize);
        let arrayY = int((screenY - offsetY) / worldTileSize);

        id = overlay[arrayY][arrayX];
    }
    return id;
}

// Changes overlay tile ID at a given screen coordinate
function setOverlayAtPosition(id, screenX, screenY) {
    // convert screen coordinates into array coordinates
    let arrayX = int((screenX - offsetX) / worldTileSize);
    let arrayY = int((screenY - offsetY) / worldTileSize);

    if (world[arrayY][arrayX] != undefined) {
        overlay[arrayY][arrayX] = id;
    }
}

// Changes overlay tile ID at a given array position `arrayX`, `arrayY`
function setOverlayAtPositionArr(id, arrayX, arrayY) {
    // convert screen coordinates into array coordinates
    if (world[arrayY][arrayX] != undefined) {
        overlay[arrayY][arrayX] = id;
    }
}

// Returns true if solid tile, false if not solid
function isSolid(id) {
    // return true for all solid tiles
    if (id === 13 || id == 2370 || id == 3998 || id == 3999 || id == 3850 || id == 3851 || id == 4297 || id == 4296 ||
        id == 4446 || id == 4440 || id == 4441 || id == 4299 || id == 4005 || id == 4006 || id == 4591 || id == 2725
        || id == 2873 || id == 6958 || id == 7106 || id == 7254 || id == 4155 || id == 3857 || id == 3856 || id == 2376 || id == 459 || id == 4593
        || id == 1697 || id == 1687 || id == 1688 || id == 1689 || id == 1690 || id == 1691 || id == 3517 || id == 3518 || id == 3519 || id == 3520
        || id == 3014 || id == 3162 || id == 3310 || id == 3458 || id == 3606 || id == 3607 || id == 3608 || id == 3609 || id == 3610 || id == 3611 || id == 3612
        || id == 3020 || id == 3168 || id == 3316 || id == 3464 || id == 3612 || id == 1786 || id == 1788
        || id == 1934 || id == 1933 || id == 1788 || id == 1784 || id == 1931 || id == 1935 || id == 1936 || id == 2368 || id == 2220 || id == 2221
        || id == 2368 || id == 2812 || id == 2517 || id == 2961 || id == 1095 || id == 1243 || id == 1391 || id == 1539 || id == 3072
        || id == 3077 || id == 3225 || id == 2584 || id == 2585 || id == 2586 || id == 1545 || id == 1546 || id == 3372 || id == 3324
        || id == 3224 || id == 3369 || id == 3221 || id == 3721 || id == 1096 || id == 1097 || id == 1098 || id == 1099
        || id == 1247 || id == 2360 || id == 2631 || id == 2778 || id == 2779 || id == 2926 || id == 2927 || id == 3074
        || id == 3075 || id == 3073 || id == 3072 || id == 3071 || id == 3076 || id == 3078 || id == 2882 || id == 3854
        || id == 3856 || id == 3720 || id == 3722 || id == 4588 || id == 4589 || id == 4595 || id == 4596
        || id == 4303 || id == 4304 || id == 4305 || id == 2664 || id == 2220 || id == 4444 || id == 4451
        || id == 2087 || id == 1800 || id == 1948 || id == 1947 || id == 1949 || id == 1945 || id == 1929 || id == 1946
        || id == 4296 || id == 4592 || id == 4589 || id == 4298 || id == 1874 || id == 1875 || id == 1876 || id == 1877 || id == 1878 || id == 2022 || id == 2023 || id == 2024 || id == 2025 || id == 2026
        || id == 2170 || id == 2171 || id == 2172 || id == 2173 || id == 2174 || id == 2318 || id == 2319 || id == 2320 || id == 2321 || id == 2322 || id == 2466
        || id == 2467 || id == 2468 || id == 2469 || id == 2470 || id == 397 || id == 398 || id == 399 || id == 400 || id == 544 || id == 545
        || id == 546 || id == 546 || id == 547 || id == 548 || id == 692 || id == 693 || id == 694 || id == 695 || id == 696 || id == 840
        || id == 841 || id == 842 || id == 843 || id == 844 || id == 988 || id == 989 || id == 900 || id == 991 || id == 992
        || id == 1936 || id == 1947 || id == 2226 || id == 2369 || id == 4594 || id == 2222 || id == 2732 || id == 2733 || id == 2734 || id == 1640
        || id == 1943 || id == 1799 || id == 1797 || id == 1798 || id == 1802 || id == 1798 || id == 1796 || id == 1399 || id == 1400
        || id == 3848 || id == 3849 || id == 3996 || id == 3997 || id == 2377 || id == 3222 || id == 3223 || id == 3370 || id == 3371
        || id == 3220 || id == 2518 || id == 1244 || id == 1245 || id == 1246 || id == 1392 || id == 1393 || id == 1394 || id == 1395
        || id == 1540 || id == 1541 || id == 1542 || id == 1543 || id == 2960 || id == 1398 || id == 2521 || id == 3015 || id == 3016
        || id == 3017 || id == 3018 || id == 3019 || id == 3163 || id == 3164 || id == 3165 || id == 3166 || id == 3167
        || id == 3311 || id == 3312 || id == 3313 || id == 3314 || id == 3315 || id == 3459 || id == 3460 || id == 3461
        || id == 3462 || id == 3463 || id == 2371 || id == 3855) {
        return true;
    }
    return false;
}

// Returns true if solid tile, false if not solid
function isSolidKitchen(id) {
    // return true for all solid tiles
    if (id === 50 || id === 47 || id === 48 || id === 0 || id === 17 ||
        id === 1 || id === 30 || id === 16 || id === 10 || id === 3 || id === 54 || id === 55 || id === 2 || id === 23
        || id === 35 || id === 8 || id === 9 || id === 23 || id === 37 || id === 24 || id === 7
        || id === -4) {
        return true;
    }
    return false;
}

// Returns true if there are no animals in that coordinate, false otherwise
function noAnimals(realX, realY, selfTileSize) {
    for (let index = 0; index < animalArr.length; index++) {
        if (dist(realX, realY, animalArr[index].x, animalArr[index].y)
            <= (animalArr[index].animalInfo.tileSize / 2 + selfTileSize / 2)) {
            return false;
        }
    }
    for (let index = 0; index < npcArr.length; index++) {
        if (stage === 1
            && dist(realX, realY, npcArr[index].x, npcArr[index].y)
            <= (npcArr[index].npcInfo.tileSizeX / 2 + selfTileSize / 2) - 15) {
            return false;
        }
        // else if (stage === 3
        //     && dist(realX + offsetX, realY + offsetY, customerArr[index].x, customerArr[index].y) <= (kitchenTileSize)) {
        //     return false;
        // }
    }
    return true;
}

function noCustomers(realX, realY, selfTileSize) {
    for (let index = 0; index < customerArr.length; index++) {
        const customer = customerArr[index];
        if (dist(realX, realY, customer.x, customer.y)
            <= (customer.npcInfo.tileSizeX / 2 + selfTileSize / 2)) {
            return false;
        }
    }
    return true;
}

let potPopUp = false;
let recipePopUp = false;
let menuPopUp = false;
// Player interacts with overlay at position `x`,`y` (triggered once after pressing `enter` button)
function interactOverlay(x, y) {
    if (stage === 1) {
        // open/ close gate
        if (getOverlayTileAtPosition(x, y) === 4299) {
            setOverlayAtPosition(4300, x, y);
            gate.play();
        }
        else if (getOverlayTileAtPosition(x, y) === 4300) {
            setOverlayAtPosition(4299, x, y);
            gate.play();
        }
        // plant or harvest crop
        else if (getWorldTileAtPosition(x, y) === 1353) {
            if (getOverlayTileAtPosition(x, y) === -1) {
                stage = 2;
            }
            else if (getOverlayTileAtPosition(x, y) === 6385) {
                harvest.play();
                setOverlayAtPosition(-1, x, y);
                wheat.amount = wheat.amount + 1;
            }
            else if (getOverlayTileAtPosition(x, y) === 5645) {
                harvest.play();
                setOverlayAtPosition(-1, x, y);
                corn.amount = corn.amount + 1;
            }
            else if (getOverlayTileAtPosition(x, y) === 5201) {
                harvest.play();
                setOverlayAtPosition(-1, x, y);
                tomato.amount = tomato.amount + 1;
            }
        }
        else if (getWorldTileAtPosition(x, y) === 2468) {
            changeStage();
        }
        else if (getWorldTileAtPosition(x, y) === 3609) {
            changeStage1();
        }
    }

    else if (stage === 2 && selectedStatus === true) {
        if (numInventorySelected >= 0 && numInventorySelected <= 2) {
            let plant = new Plant(x, y, inventoryArray[numInventorySelected].plantName);
            plantArr.push(plant);
            plop.play();
            inventoryArray[numInventorySelected].amount--;
        }
    }
    else if (stage === 3) {
        // console.log(getOverlayTileAtPosition(x, y));
        if (getOverlayTileAtPosition(x, y) === 24) {
            if (!potPopUp && pot.cooking === 0 && player.holding === false) {
                ingredientSelected = false;
                potPopUp = !potPopUp;
            }
            else if (!potPopUp && pot.cooking === 2) {
                player.holding = true;
                player.holdingPlate = pot.recipe;
                pot.cooking = 0;
                get_food.play();
            }
            else if (ingredientSelected && pot.insidePotArr.length < 3) {
                let totalIngredients = 1;
                for (let i = 0; i < pot.insidePotArr.length; i++) {
                    if (pot.insidePotArr[i] === numIngredientSelected) {
                        totalIngredients++;
                    }
                }
                if (inventoryArray[numIngredientSelected].amount >= totalIngredients) {
                    pot.insidePotArr.push(numIngredientSelected);
                    put_food.play();
                }
            }
        }
        else if (getOverlayTileAtPosition(x, y) === 7) {
            if (!menuPopUp) {
                menuShowing = 0;
                menuPopUp = !menuPopUp;
            }
        }
        else if (getOverlayTileAtPosition(x, y) === 8) {
            if (player.holding) {
                player.holding = false;
                player.holdingPlate = -1;
                disposalSound.play();
            }
        }
    }

}

// Displays a white box around selected item in inventory
function displaySelectedBox(itemNum) {
    if (!selectedStatus) {
        return;
    }

    stroke(255);
    strokeWeight(3);

    let yMin, yMax, xMin, xMax;
    let itemSize = 37;
    let itemDist = itemSize + 9;
    yMin = 160;
    yMax = yMin + itemSize;

    xMin = 87 + (itemNum * itemDist);
    xMax = xMin + itemSize;

    line(xMin, yMin, xMax, yMin);
    line(xMin, yMax, xMax, yMax);
    line(xMin, yMin, xMin, yMax);
    line(xMax, yMin, xMax, yMax);

    noStroke();
}

function displaySelectedBox1(itemNum) {
    if (!selectedStatus1) {
        return;
    }

    stroke(255);
    strokeWeight(3);

    let yMin, yMax, xMin, xMax;
    let itemSize = 62;
    let itemDist = itemSize + 23;
    yMin = 77;
    yMax = yMin + itemSize;

    xMin = 635 + (itemNum * itemDist);
    xMax = xMin + itemSize;

    line(xMin, yMin, xMax, yMin);
    line(xMin, yMax, xMax, yMax);
    line(xMin, yMin, xMin, yMax);
    line(xMax, yMin, xMax, yMax);

    noStroke();
}
// Shows a small bar on the bottom of the screen while playing the game
// that displays the images and numbers of produce you have obtained
function showProduceInventory() {
    let tileDist = 5;
    let produceNum = 5;
    let barWidth = tileDist + (inventoryTileSize + tileDist) * produceNum, barHeight = 42;
    let barStartX = width / 2 - barWidth / 2, barStartY = height - barHeight;

    strokeWeight(5);
    stroke(120, 65, 0);
    fill(150, 75, 0);
    rect(barStartX, barStartY, barWidth, barHeight);

    strokeWeight(2);
    for (let i = 3; i < 8; i++) {
        image(inventoryArray[i].graphic, barStartX + 5 + ((tileDist + inventoryTileSize) * (i - 3)), barStartY + 5);
        fill(255);
        textSize(15);
        text(inventoryArray[i].amount, barStartX + 6 + ((tileDist + inventoryTileSize) * (i - 3)), barStartY + 13);
    }
    noStroke();
}

// Shows a small bar on the bottom of the screen while playing the game
// that displays the images and numbers of produce you have obtained
function showIngredients() {
    let tileDist = 5;
    let produceNum = 5;
    let barWidth = tileDist + (inventoryTileSize + tileDist) * produceNum, barHeight = 42;
    let subBarWidth = tileDist + (inventoryTileSize + tileDist) * 3;
    let barStartX = player.x - barWidth / 2, barStartY = player.y - barHeight - kitchenTileSize;

    strokeWeight(5);
    stroke(120, 65, 0);
    fill(150, 75, 0);
    rect(barStartX, barStartY, barWidth, barHeight);
    rect(barStartX + (inventoryTileSize + tileDist), barStartY - (inventoryTileSize + tileDist * 3), subBarWidth, barHeight);

    strokeWeight(2);
    for (let i = 3; i < 8; i++) {
        image(inventoryArray[i].graphic, barStartX + 5 + ((tileDist + inventoryTileSize) * (i - 3)), barStartY + 5);
        fill(255);
        textSize(15);
        text(inventoryArray[i].amount, barStartX + 6 + ((tileDist + inventoryTileSize) * (i - 3)), barStartY + 13);
    }
    displayIngredientSelected(numIngredientSelected - 3, barStartX, barStartY);
    displayInsidePot(barStartX + (inventoryTileSize + tileDist),
        barStartY - (inventoryTileSize + tileDist * 3), (tileDist + inventoryTileSize));
    noStroke();
}

// Displays a white box around selected item in inventory
function displayIngredientSelected(itemNum, barStartX, barStartY) {
    if (!ingredientSelected) {
        return;
    }

    stroke(255, 255, 255, 200);
    strokeWeight(3);

    let yMin, yMax, xMin, xMax;
    let itemSize = 37;
    yMin = barStartY + 1;
    yMax = yMin + itemSize;

    xMin = barStartX + (itemNum * itemSize) + 2.5;
    xMax = xMin + itemSize;

    line(xMin, yMin, xMax, yMin);
    line(xMin, yMax, xMax, yMax);
    line(xMin, yMin, xMin, yMax);
    line(xMax, yMin, xMax, yMax);

    noStroke();
}

function displayInsidePot(barStartX, barStartY, dist) {
    strokeWeight(2);
    for (let i = 0; i < pot.insidePotArr.length; i++) {
        image(inventoryArray[pot.insidePotArr[i]].graphic, barStartX + 5 + (dist * i), barStartY + 5);
    }
}

let menuShowing = 0;
function showMenu() {
    imageMode(CENTER);
    let img = pot.recipeBook[menuShowing].menu;
    drawTile(img, 0, img.width, img.height, width / 2, height / 2, width / 2, height / 2);
    imageMode(CORNER);
}


let ampm = 1;
let startTime = 7;
let secToMin = 2;
let alphaNum = 0;
let lerpNum = 0;
function displayTime() {
    fill(255);
    let secondsPassed = millis() / 1000, minutesPassed = (int)(secondsPassed * secToMin);
    let hoursNum = (int)(startTime + ((minutesPassed / 60))) % 24;
    let minsNum = (minutesPassed % 60);
    if (hoursNum >= 12 && hoursNum < 24) {
        ampm = 0;
    } else {
        ampm = 1;
    }
    let hours = ("0" + hoursNum % 12).slice(-2);
    if (hoursNum % 12 === 0) {
        hours = "12";
    }
    minutes = ("0" + minsNum).slice(-2);
    let time = hours + ":" + minutes + (ampm ? " AM" : " PM");
    text(time, width - 80, 30);

    // slowly get dark... get red then get dark
    // From 6PM to 8PM 18 --> 20
    let sunset = color(253, 94, 83);
    let dusk = color(78, 84, 129);
    if (hoursNum >= 18 && hoursNum <= 20) {
        if (hoursNum === 18) {
            alphaNum = minsNum * (50 / 60);
        } else {
            alphaNum = 50;
        }
        sunset.setAlpha(alphaNum);
        fill(sunset);
        rect(0, 0, width, height);
    }
    // From 9PM to 6AM  21 --> 6
    else if ((hoursNum >= 21) || (hoursNum <= 5)) {
        if (hoursNum === 21) {
            lerpNum = minsNum * (1 / 60);
        } else {
            lerpNum = 1;
        }
        colorMode(RGB);
        let moonlight = lerpColor(sunset, dusk, lerpNum);
        moonlight.setAlpha(50);
        fill(moonlight);
        rect(0, 0, width, height);
    }
    else if ((hoursNum <= 6)) {
        alphaNum = (60 - minsNum) * (50 / 60);
        dusk.setAlpha(alphaNum);
        fill(dusk);
        rect(0, 0, width, height);
    }
    else {
        alphaNum = 0;
        lerpNum = 0;
    }
}


let tablesOccupied = [];
let tableChairs = [[4, 5], [2, 5], [9, 5], [7, 5]];
let tables = [[3, 5], [8, 5]];

function newCustomer() {
    let table, chair;
    console.log(tablesOccupied);
    if (tablesOccupied.includes(0)) {
        table = 1;
    } else if (tablesOccupied.includes(1)) {
        table = 0;
    } else {
        table = floor(random(2));
    }
    tablesOccupied.push(table);
    chair = floor(random(2));
    let index = (table * 2) + chair;
    let to = tableChairs[index];
    let customer = new NPC(12, 7, to[0], to[1], kitchenTileSize, 2);
    customer.chair = chair;
    customer.table = table;
    customerArr.push(customer);
}

function removeCustomer(id) {
    let c = customerArr.findIndex(c => c.id === id);
    let customer = customerArr[c];
    customerArr.splice(c, 1);
    tablesOccupied.splice(tablesOccupied.findIndex(i => i === customer.table), 1);
}

function showFood(table, id) {
    let x = tables[table][0], y = tables[table][1];
    drawTile(pot.recipeBook[id].plate, 0, pot.recipeBook[id].plate.width, pot.recipeBook[id].plate.height,
        x * kitchenTileSize + kitchenOffsetX + kitchenTileSize / 2, y * kitchenTileSize + kitchenOffsetY + kitchenTileSize / 4,
        kitchenTileSize * (3 / 4), kitchenTileSize * (3 / 5));
}


/**
 * CLASSES
 */
class Player {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.speed = 4;
        // 0 = down
        // 1 = right
        // 2 = left
        // 3 = up
        this.direction = 0;
        this.walking = true;

        this.totalFrames = 4;
        this.currentFrame = 0;
        this.pauseCounter = 0;
        this.pauseCounterMax = 20;

        this.facingTile = [];

        this.tileSize = 32;

        this.holding = false;
        this.holdingPlate = -1;
    }

    computeSensors() {
        this.middleX = this.x;
        this.middleY = this.y;
        this.left = int(this.x - this.tileSize / 4 - 2);
        this.right = int(this.x + this.tileSize / 4 + 2);
        this.up = int(this.y - this.tileSize / 4 - 2);
        this.down = int(this.y + this.tileSize / 4 + 2);
    }

    changeEnvironment() {
        let tempX, tempY;
        if (this.direction === 0) {
            tempX = this.middleX;
            tempY = this.down;
        } else if (this.direction === 1) {
            tempX = this.right;
            tempY = this.middleY;
        } else if (this.direction === 2) {
            tempX = this.left;
            tempY = this.middleY;
        } else {
            tempX = this.middleX;
            tempY = this.up;
        }
        interactOverlay(tempX, tempY);
        if (stage === 1) {
            for (let index = 0; index < animalArr.length; index++) {
                animalArr[index].lookAtPlayer(tempX, tempY);
            }
            for (let index = 0; index < npcArr.length; index++) {
                npcArr[index].lookAtPlayer(tempX, tempY);
            }
        } else if (stage === 3) {
            for (let index = 0; index < customerArr.length; index++) {
                let correct = customerArr[index].takeOrder(tempX, tempY, this.holdingPlate);
                if (correct) {
                    this.holdingPlate = -1;
                    this.holding = false;
                }
            }
        }
    }

    showPlate() {
        if (this.holding) {
            let img = pot.recipeBook[this.holdingPlate].plate;
            drawTile(img, 0, img.width, img.height, this.x, this.y - kitchenTileSize / 2, kitchenTileSize / 1.5, kitchenTileSize / 1.5);
        }
    }

    moveAndDisplay(displayX, displayY) {
        imageMode(CENTER);
        this.facing = [];
        this.computeSensors();
        this.walking = false;

        // movement
        if (keyIsDown(68)) {
            // ellipse(this.right, this.middleY, 5, 5);
            let id = getWorldTileAtPosition(this.right, this.middleY);
            let id2 = getOverlayTileAtPosition(this.right, this.middleY);
            if (!isSolid(id) && !isSolid(id2) && noAnimals(this.right - offsetX, this.middleY - offsetY, this.tileSize)) {
                if (offsetX > minOffsetX && this.x === (width / 2)) {
                    offsetX -= this.speed;
                } else {
                    this.x += this.speed;
                }
            }
            if (!keyIsDown(87) && !keyIsDown(83)) {
                this.direction = 1;
            }
            this.walking = true;

        }
        if (keyIsDown(65)) {
            // ellipse(this.left, this.middleY, 5, 5);
            let id = getWorldTileAtPosition(this.left, this.middleY);
            let id2 = getOverlayTileAtPosition(this.left, this.middleY);
            if (!isSolid(id) && !isSolid(id2) && noAnimals(this.left - offsetX, this.middleY - offsetY, this.tileSize)) {
                if (offsetX < 0 && this.x === (width / 2)) {
                    offsetX += this.speed;
                } else {
                    this.x -= this.speed;
                }
            }
            if (!keyIsDown(87) && !keyIsDown(83)) {
                this.direction = 2;
            }
            this.walking = true;

        }
        if (keyIsDown(87)) {
            // ellipse(this.middleX, this.up, 5, 5);
            let id = getWorldTileAtPosition(this.middleX, this.up);
            let id2 = getOverlayTileAtPosition(this.middleX, this.up);
            if (!isSolid(id) && !isSolid(id2) && noAnimals(this.middleX - offsetX, this.up - offsetY, this.tileSize)) {
                if (offsetY < 0 && this.y === (height / 2)) {
                    offsetY += this.speed;
                } else {
                    this.y -= this.speed;
                }
            }
            if (!keyIsDown(68) && !keyIsDown(65)) {
                this.direction = 3;
            }
            this.walking = true;

        }
        if (keyIsDown(83)) {
            // ellipse(this.middleX, this.down, 5, 5);
            let id = getWorldTileAtPosition(this.middleX, this.down);
            let id2 = getOverlayTileAtPosition(this.middleX, this.down);
            if (!isSolid(id) && !isSolid(id2) && noAnimals(this.middleX - offsetX, this.down - offsetY, this.tileSize)) {
                if (offsetY > minOffsetY && this.y === (height / 2)) {
                    offsetY -= this.speed;
                } else {
                    this.y += this.speed;
                }
            }
            if (!keyIsDown(68) && !keyIsDown(65)) {
                this.direction = 0;
            }
            this.walking = true;

        }

        // frame animation
        if (this.walking) {
            this.pauseCounter--;

            if (this.pauseCounter <= 0) {
                this.currentFrame += 1;
                if (this.currentFrame >= this.totalFrames) {
                    this.currentFrame = 0;
                }
                this.pauseCounter = this.pauseCounterMax;
            }

            drawTile(playerArtwork, (this.direction * 4) + this.currentFrame,
                playerTileSizeX, playerTileSizeY, this.x, this.y, displayX, displayY);
        } else {
            drawTile(playerArtwork, (this.direction * 4), playerTileSizeX, playerTileSizeY,
                this.x, this.y, displayX, displayY);
        }
        imageMode(CORNER);
    }

    moveAndDisplayKitchen() {
        let speed = this.speed / 2;
        imageMode(CENTER);
        this.facing = [];
        this.computeSensors();
        this.up = int(this.y - 2);
        this.down = int(this.y + kitchenTileSize / 2)
        this.walking = false;

        // movement
        if (keyIsDown(68)) {
            // ellipse(this.right, this.middleY, 5, 5);
            let id = getWorldTileAtPosition(this.right, this.middleY);
            let id2 = getOverlayTileAtPosition(this.right, this.middleY);
            if (!isSolidKitchen(id) && !isSolidKitchen(id2)
                && noCustomers(this.right - kitchenOffsetX, this.middleY - kitchenOffsetY, this.tileSize)) {
                if (kitchenOffsetX > minOffsetXKitchen && this.x === (width / 2)) {
                    kitchenOffsetX -= speed;
                } else {
                    this.x += speed;
                }
            }
            if (!keyIsDown(87) && !keyIsDown(83)) {
                this.direction = 1;
            }
            this.walking = true;

        }
        if (keyIsDown(65)) {
            // ellipse(this.left, this.middleY, 5, 5);
            let id = getWorldTileAtPosition(this.left, this.middleY);
            let id2 = getOverlayTileAtPosition(this.left, this.middleY);
            if (!isSolidKitchen(id) && !isSolidKitchen(id2)
                && noCustomers(this.left - kitchenOffsetX, this.middleY - kitchenOffsetY, this.tileSize)) {
                if (kitchenOffsetX < 0 && this.x === (width / 2)) {
                    kitchenOffsetX += speed;
                } else {
                    this.x -= speed;
                }
            }
            if (!keyIsDown(87) && !keyIsDown(83)) {
                this.direction = 2;
            }
            this.walking = true;

        }
        if (keyIsDown(87)) {
            // ellipse(this.middleX, this.up, 5, 5);
            let id = getWorldTileAtPosition(this.middleX, this.up);
            let id2 = getOverlayTileAtPosition(this.middleX, this.up);
            if (!isSolidKitchen(id) && !isSolidKitchen(id2)
                && noCustomers(this.middleX - kitchenOffsetX, this.up - kitchenOffsetY, this.tileSize)) {
                if (kitchenOffsetY < 0 && this.y === (height / 2)) {
                    kitchenOffsetY += speed;
                } else {
                    this.y -= speed;
                }
            }
            if (!keyIsDown(68) && !keyIsDown(65)) {
                this.direction = 3;
            }
            this.walking = true;

        }
        if (keyIsDown(83)) {
            // ellipse(this.middleX, this.down, 5, 5);
            let id = getWorldTileAtPosition(this.middleX, this.down);
            let id2 = getOverlayTileAtPosition(this.middleX, this.down);
            if (!isSolidKitchen(id) && !isSolidKitchen(id2)
                && noCustomers(this.middleX - kitchenOffsetX, this.down - kitchenOffsetY, this.tileSize)) {
                if (kitchenOffsetY > minOffsetYKitchen && this.y === (height / 2)) {
                    kitchenOffsetY -= speed;
                } else {
                    this.y += speed;
                }
            }
            if (!keyIsDown(68) && !keyIsDown(65)) {
                this.direction = 0;
            }
            this.walking = true;

        }

        // frame animation
        if (this.walking) {
            this.pauseCounter--;

            if (this.pauseCounter <= 0) {
                this.currentFrame += 1;
                if (this.currentFrame >= this.totalFrames) {
                    this.currentFrame = 0;
                }
                this.pauseCounter = this.pauseCounterMax;
            }

            drawTile(playerArtwork, (this.direction * 4) + this.currentFrame,
                playerTileSizeX, playerTileSizeY, this.x, this.y, kitchenTileSize, kitchenTileSize);
        } else {
            drawTile(playerArtwork, (this.direction * 4), playerTileSizeX, playerTileSizeY,
                this.x, this.y, kitchenTileSize, kitchenTileSize);
        }

        this.showPlate();

        imageMode(CORNER);
    }
}

class Plant {
    constructor(screenX, screenY, plantName) {
        this.arrayX = int((screenX - offsetX) / worldTileSize);
        this.arrayY = int((screenY - offsetY) / worldTileSize);
        this.plantInfo = plantInfoAll[plantName];
        this.sproutPos = 0;
        setOverlayAtPositionArr(this.plantInfo.sproutArr[this.sproutPos], this.arrayX, this.arrayY);
        this.maxFrames = 120;
        this.currentFrames = 0;
        // 0 = growing
        // 1 = harvestable
        this.state = 0;
    }

    // count frames and change overlay image
    display() {
        if (this.state === 0) {
            if (this.currentFrames >= this.maxFrames) {
                this.sproutPos++;
                if (this.sproutPos < this.plantInfo.sproutArr.length) {
                    setOverlayAtPositionArr(this.plantInfo.sproutArr[this.sproutPos], this.arrayX, this.arrayY);
                    this.currentFrames = 0;
                } else {
                    setOverlayAtPositionArr(this.plantInfo.harvestableId, this.arrayX, this.arrayY);
                    this.state = 1;
                }
            }
            this.currentFrames++;
        }
    }
}

class Animal {
    constructor(arrayX, arrayY, animalName) {
        this.x = arrayX * worldTileSize;
        this.y = arrayY * worldTileSize;
        this.animalName = animalName;
        this.animalInfo = animalInfoAll[animalName];
        this.spritePos = 0;
        this.currentFrames = 0;
        this.maxFrames = 20;
        this.walkingTimer = 0;
        this.maxWalkingTimer = 160;
        this.restingTimer = 239;
        this.maxRestingTimer = 240;
        // 0 = growing
        // 1 = harvestable
        this.state = 0;
        // 0 = down
        // 1 = up
        // 2 = left
        // 3 = right
        // 4 = sleeping
        this.direction = 0;
        this.tilesPerRow = this.animalInfo.img.width / this.animalInfo.tileSize;
        this.walking = false;
        this.speed = 0.2;
        this.emote = 0;
        this.emoteTimer = 0;
        this.maxEmoteTimer = 60;
        this.emoting = false;
        this.emoteCoolDown = 0;
        this.maxEmoteCoolDown = 100;
        this.itemCoolDown = 0;
        this.maxItemCoolDown = 60;
    }

    // there are no animals or players at the place the animal is trying to move
    noAnimalsOrPlayer(realX, realY) {
        for (let index = 0; index < animalArr.length; index++) {
            if (animalArr[index] === this) {
                continue;
            }
            if (dist(realX, realY, animalArr[index].x, animalArr[index].y)
                <= (animalArr[index].animalInfo.tileSize / 2 + this.animalInfo.tileSize / 2)) {
                return false;
            }
        }
        if (dist(realX, realY, player.x - offsetX, player.y - offsetY) <= player.tileSize / 2 + this.animalInfo.tileSize / 2) {
            return false;
        }
        for (let index = 0; index < npcArr.length; index++) {
            if (dist(realX, realY, npcArr[index].x, npcArr[index].y)
                <= (npcArr[index].npcInfo.tileSizeX / 2 + this.animalInfo.tileSize / 2)) {
                return false;
            }
        }
        return true;
    }

    // there are no animals or players at the place the animal is trying to move
    noPlayer(realX, realY) {
        if (dist(realX, realY, player.x - offsetX, player.y - offsetY) <= player.tileSize / 2 + this.animalInfo.tileSize / 2) {
            return false;
        }
        return true;
    }

    // get world tile
    getWorldTileAtPosition(realX, realY) {
        // convert screen coordinates into array coordinates
        let arrayX = int(realX / worldTileSize);
        let arrayY = int(realY / worldTileSize);

        let id = world[arrayY][arrayX];
        return id;
    }

    // get overlay tile
    getOverlayTileAtPosition(realX, realY) {
        // convert screen coordinates into array coordinates
        let arrayX = int(realX / worldTileSize);
        let arrayY = int(realY / worldTileSize);

        let id = overlay[arrayY][arrayX];
        return id;
    }

    // If the player presses `enter` in front of the animal
    // make the animal look at the player (uses slope logic)
    // Also harvests produce from adult animals
    lookAtPlayer(screenX, screenY) {
        let realX = screenX - offsetX;
        let realY = screenY - offsetY;
        if (dist(realX, realY, this.x, this.y) > (this.animalInfo.tileSize / 2 + player.tileSize / 2)) {
            return;
        }
        let slope;
        if (realX < this.x) {
            slope = (this.y - realY) / (this.x - realX);
        } else {
            slope = (realY - this.y) / (realX - this.x);
        }
        if (slope > 0) {
            if (slope < 1) {
                if (this.x > realX) {
                    // left
                    this.direction = 2;
                } else {
                    // right
                    this.direction = 3;
                }
            } else {
                if (this.y > realY) {
                    // up
                    this.direction = 1;
                } else {
                    // down
                    this.direction = 0;
                }
            }
        } else {
            if (slope > -1) {
                if (this.x > realX) {
                    // left
                    this.direction = 2;
                } else {
                    // right
                    this.direction = 3;
                }
            } else {
                if (this.y > realY) {
                    // up
                    this.direction = 1;
                } else {
                    // down
                    this.direction = 0;
                }
            }
        }
        if (this.itemCoolDown <= 0) {
            if (this.animalName === "cow") {
                milk.amount = milk.amount + 1;
                adultMoo.play();
            }
            if (this.animalName === "cowBaby") {
                calfMoo.play();
            }
            if (this.animalName === "chicken") {
                eggs.amount = eggs.amount + 1;
                adultChicken.play();
            }
            if (this.animalName === "chickenBaby") {
                chicks.play();
            }
            this.itemCoolDown = this.maxItemCoolDown;
        }
        this.spritePos = 0;
        this.currentFrames = 0;
        this.walkingTimer = 0;
        this.restingTimer = 0;
        this.walking = false;
        if (this.emoteCoolDown <= 0) {
            this.emoteTimer = 0;
            this.emoting = true;
            // have happy emotes be more likely
            if (random(3) > 1) {
                this.emote = floor(random(7));
            } else {
                this.emote = floor(random(emotes.length));
            }
            this.emoteCoolDown = this.maxEmoteCoolDown;
            bubblePop.play();
        }
    }

    // Animals change direction and move randomly in four directions (or sleeps) after a certain amount of time
    // They check if the place they are trying to go is okay to go to, has constant speed
    // Also inclues frame animation
    moveAndDisplay() {
        imageMode(CENTER);
        // the chicken png has the left and right images flipped from the others :(
        // how inconvenient
        if (this.animalName === 'chicken') {
            let directionTemp;
            if (this.direction === 2) {
                directionTemp = 3;
            } else if (this.direction === 3) {
                directionTemp = 2;
            } else {
                directionTemp = this.direction;
            }
            drawTile(this.animalInfo.img, (directionTemp * this.tilesPerRow) + this.spritePos,
                this.animalInfo.tileSize, this.animalInfo.tileSize,
                this.x + offsetX, this.y + offsetY,
                this.animalInfo.tileSize, this.animalInfo.tileSize,);
        } else {
            drawTile(this.animalInfo.img, (this.direction * this.tilesPerRow) + this.spritePos,
                this.animalInfo.tileSize, this.animalInfo.tileSize,
                this.x + offsetX, this.y + offsetY,
                this.animalInfo.tileSize, this.animalInfo.tileSize,);
        }

        // the animal is walking
        if (this.walking) {
            if (this.currentFrames >= this.maxFrames) {
                if (this.spritePos + 1 < this.tilesPerRow) {
                    this.spritePos++;
                } else {
                    this.spritePos = 0;
                }
                this.currentFrames = 0;
            }
            this.currentFrames++;

            if (this.direction === 0 && this.noPlayer(this.x, this.y + this.speed)) {
                this.y += this.speed;
                this.walkingTimer++;
            } else if (this.direction === 1 && this.noPlayer(this.x, this.y - this.speed)) {
                this.y -= this.speed;
                this.walkingTimer++;
            } else if (this.direction === 2 && this.noPlayer(this.x - this.speed, this.y)) {
                this.x -= this.speed;
                this.walkingTimer++;
            } else if (this.direction === 3 && this.noPlayer(this.x + this.speed, this.y)) {
                this.x += this.speed;
                this.walkingTimer++;
            }

            if (this.walkingTimer >= this.maxWalkingTimer) {
                this.walkingTimer = 0;
                this.walking = false;
            }
        } else {
            this.spritePos = 0;
            this.restingTimer++;
            if (this.restingTimer >= this.maxRestingTimer) {
                this.direction = int(random(5));
                this.restingTimer = 0;

                if (this.direction === 0) {
                    if (!isSolid(this.getWorldTileAtPosition(this.x, this.y + (this.maxWalkingTimer * this.speed)))
                        && !isSolid(this.getOverlayTileAtPosition(this.x, this.y + (this.maxWalkingTimer * this.speed)))
                        && this.noAnimalsOrPlayer(this.x, this.y + (this.maxWalkingTimer * this.speed))) {
                        if (random(3) < 2) {
                            this.walking = true;
                        }
                    }
                } else if (this.direction === 1) {
                    if (!isSolid(this.getWorldTileAtPosition(this.x, this.y - (this.maxWalkingTimer * this.speed)))
                        && !isSolid(this.getOverlayTileAtPosition(this.x, this.y - (this.maxWalkingTimer * this.speed)))
                        && this.noAnimalsOrPlayer(this.x, this.y - (this.maxWalkingTimer * this.speed))) {
                        if (random(3) < 2) {
                            this.walking = true;
                        }
                    }
                } else if (this.direction === 2) {
                    if (!isSolid(this.getWorldTileAtPosition(this.x - (this.maxWalkingTimer * this.speed), this.y))
                        && !isSolid(this.getOverlayTileAtPosition(this.x - (this.maxWalkingTimer * this.speed), this.y))
                        && this.noAnimalsOrPlayer(this.x - (this.maxWalkingTimer * this.speed), this.y)) {
                        if (random(3) < 2) {
                            this.walking = true;
                        }
                    }
                } else if (this.direction === 3) {
                    if (!isSolid(this.getWorldTileAtPosition(this.x + (this.maxWalkingTimer * this.speed), this.y))
                        && !isSolid(this.getOverlayTileAtPosition(this.x + (this.maxWalkingTimer * this.speed), this.y))
                        && this.noAnimalsOrPlayer(this.x + (this.maxWalkingTimer * this.speed), this.y)) {
                        if (random(3) < 2) {
                            this.walking = true;
                        }
                    }
                } else {
                    this.walking = true;
                }
            }
        }
        imageMode(CORNER);
    }

    // Display emote on the right left of character
    displayEmote() {
        imageMode(CENTER);
        if (this.emoting) {
            image(emotes[this.emote], this.x + offsetX + this.animalInfo.tileSize / 2, this.y + offsetY - this.animalInfo.tileSize / 4, 27, 27);

            if (this.emoteTimer < this.maxEmoteTimer) {
                this.emoteTimer++;
            } else {
                this.emoteTimer = 0;
                this.emoting = false;
            }
        }
        if (this.emoteCoolDown >= 0) {
            this.emoteCoolDown--;
        }
        if (this.itemCoolDown >= 0) {
            this.itemCoolDown--;
        }
        imageMode(CORNER);
    }
}

// The inventory items
// if it is a seed item, store the produce name for when you harvest it (convenient)
class Item {
    constructor(itemName, itemAmount, img) {
        this.name = itemName;
        this.amount = itemAmount;
        this.graphic = img;
        if (this.name.includes("Seeds")) {
            let nameArray = this.name.toLowerCase().split(" ");
            this.plantName = nameArray[0];
        }
    }
}
class Item1 {
    constructor(itemName, itemAmount, img) {
        this.name = itemName;
        this.amount = itemAmount;
        this.graphic = img;
        if (this.name.includes("Seeds")) {
            let nameArray = this.name.toLowerCase().split(" ");
            this.plantName = nameArray[0];
        }
    }
}


class NPC {
    constructor(arrayX, arrayY, destX, destY, worldTileSize, mode) {
        this.x = arrayX * worldTileSize + worldTileSize / 2;
        this.y = arrayY * worldTileSize + worldTileSize / 2;
        this.mode = mode;
        // this.nodeX = int( this.x / cellSize );
        // this.nodeY = int( this.y / cellSize );
        this.destX = destX;
        this.destY = destY;
        this.nodeX = int(this.x / worldTileSize);
        this.nodeY = int(this.y / worldTileSize);
        this.grid = [];
        this.initGrid();
        this.findPaths(this.nodeX, this.nodeY, this.destX, this.destY);
        // this.customerFindPath();
        this.desiredX = this.grid[this.nodeY][this.nodeX].nextX * worldTileSize + worldTileSize / 2;
        this.desiredY = this.grid[this.nodeY][this.nodeX].nextY * worldTileSize + worldTileSize / 2;

        this.nodeHistory = [];
        this.nodeHistory.push([this.nodeX, this.nodeY]);

        this.dead = false;
        this.walking = floor(random(2));

        this.charID = floor(random(3));
        // 0 = down
        // 1 = left
        // 2 = right
        // 3 = up
        this.direction = 0;
        this.npcInfo = npcInfoAll[this.charID];
        this.spritePos = 0;
        this.currentFrames = 0;
        this.maxFrames = 20;

        this.emote = 0;
        this.emoteTimer = 0;
        this.maxEmoteTimer = 60;
        this.emoting = false;
        this.emoteCoolDown = 0;
        this.maxEmoteCoolDown = 100;

        this.idleTimer = 0;
        this.maxIdleTimer = 240;

        // for customers
        if (this.mode === 2) {
            if (customerArr.length >= 1) {
                this.id = 1 - customerArr[0].id;
            } else {
                this.id = 0;
            }
            this.order = floor(random(3));
            this.table = -1;
            this.chair = -1;
            this.walking = true;
            this.maxIdleTimer = 600;
            this.ordering = false;
        }
    }

    findPaths(startX, startY, endX, endY) {
        // step 1: clear all existing pathfinding information in the grid
        for (var i = 0; i < this.grid.length; i++) {
            for (var j = 0; j < this.grid[i].length; j++) {
                this.grid[i][j].stepsToEnd = -1;
                this.grid[i][j].nextX = "unknown";
                this.grid[i][j].nextY = "unknown";
                this.grid[i][j].dx = 0;
                this.grid[i][j].dy = 0;
                this.grid[i][j].nextDirection = -1;
            }
        }

        // step 2: mark the end path as 0 steps
        this.grid[endY][endX].stepsToEnd = 0;
        this.grid[endY][endX].nextX = "none";
        this.grid[endY][endX].nextY = "none";
        this.grid[endY][endX].dx = 0;
        this.grid[endY][endX].dy = 0;
        this.grid[endY][endX].nextDirection = -1;

        // step 3: find all this loop keeps calling 'findPathIterative' until all cells in the grid have
        // pointers to the optimal end path
        while (true) {
            if (this.findPathIterative(startX, startY) === 0) {
                break;
            }
        }
    }

    findPathIterative(startX, startY) {
        // start off by making a deep copy of the entire array
        var gridCopy = this.makeDeepCopy(this.grid);

        // assume we need to make 0 changes to the pathing info in the grid - this is important
        // since if this number fails to change during the computation phase below we can assume
        // that we have computed a valid optimal path to the end cell
        var numChanges = 0;

        // visit every cell in the grid
        for (var y = 0; y < this.grid.length; y++) {
            for (var x = 0; x < this.grid[y].length; x++) {
                // only need to do something if this is tile is not solid or we know pathing info for the tile already
                if (this.grid[y][x].solid === false && this.grid[y][x].stepsToEnd == -1) {
                    // check element: RIGHT
                    if (x < this.grid[y].length - 1) {
                        // is it solid and do we know the pathfinding info for this tile?
                        if (this.grid[y][x + 1].solid === false && this.grid[y][x + 1].stepsToEnd >= 0) {
                            // mark this tile with pathfinding info based on the cell we are visiting (+1)
                            gridCopy[y][x].stepsToEnd = this.grid[y][x + 1].stepsToEnd + 1;
                            gridCopy[y][x].nextX = x + 1;
                            gridCopy[y][x].nextY = y;
                            gridCopy[y][x].dx = 1;
                            gridCopy[y][x].dy = 0;
                            gridCopy[y][x].nextDirection = "right";

                            if (this.checkEnd(x + 1, y, startX, startY)) {
                                return 0;
                            }

                            numChanges++;
                        }
                    }

                    // check element: LEFT
                    if (x >= 1) {
                        // is it solid and do we know the pathfinding info for this tile?
                        if (this.grid[y][x - 1].solid === false && this.grid[y][x - 1].stepsToEnd >= 0) {
                            // mark this tile with pathfinding info based on the cell we are visiting (+1)
                            gridCopy[y][x].stepsToEnd = this.grid[y][x - 1].stepsToEnd + 1;
                            gridCopy[y][x].nextX = x - 1;
                            gridCopy[y][x].nextY = y;
                            gridCopy[y][x].dx = -1;
                            gridCopy[y][x].dy = 0;
                            gridCopy[y][x].nextDirection = "left";

                            if (this.checkEnd(x - 1, y, startX, startY)) {
                                return 0;
                            }

                            numChanges++;
                        }
                    }

                    // check element: DOWN
                    if (y < this.grid.length - 1) {
                        // is it solid and do we know the pathfinding info for this tile?
                        if (this.grid[y + 1][x].solid === false && this.grid[y + 1][x].stepsToEnd >= 0) {
                            // mark this tile with pathfinding info based on the cell we are visiting (+1)
                            gridCopy[y][x].stepsToEnd = this.grid[y + 1][x].stepsToEnd + 1;
                            gridCopy[y][x].nextX = x;
                            gridCopy[y][x].nextY = y + 1;
                            gridCopy[y][x].dx = 0;
                            gridCopy[y][x].dy = 1;
                            gridCopy[y][x].nextDirection = "down";

                            if (this.checkEnd(x, y + 1, startX, startY)) {
                                return 0;
                            }

                            numChanges++;
                        }
                    }

                    // check element: UP
                    if (y >= 1) {
                        // is it solid and do we know the pathfinding info for this tile?
                        if (this.grid[y - 1][x].solid === false && this.grid[y - 1][x].stepsToEnd >= 0) {
                            // mark this tile with pathfinding info based on the cell we are visiting (+1)
                            gridCopy[y][x].stepsToEnd = this.grid[y - 1][x].stepsToEnd + 1;
                            gridCopy[y][x].nextX = x;
                            gridCopy[y][x].nextY = y - 1;
                            gridCopy[y][x].dx = 0;
                            gridCopy[y][x].dy = -1;
                            gridCopy[y][x].nextDirection = "up";

                            if (this.checkEnd(x, y - 1, startX, startY)) {
                                return 0;
                            }

                            numChanges++;
                        }
                    }
                }
            }
        }

        // update the grid with the copy that we made
        this.grid = gridCopy;

        // tell the caller how many changes we made (if 0 the caller will stop the 'while' loop and a path has been computed)
        return numChanges;
    }

    checkEnd(x1, y1, x2, y2) {
        if (x1 === x2 && y1 === y2) {
            return true;
        } else {
            return false;
        }
    }

    makeDeepCopy(g) {
        var gridCopy = [];

        for (var y = 0; y < g.length; y++) {
            var newRow = [];

            for (var x = 0; x < g[y].length; x++) {
                var newObj = {};

                for (var property in g[y][x]) {
                    newObj[property] = g[y][x][property];
                }

                newRow.push(newObj);
            }

            gridCopy.push(newRow);
        }

        return gridCopy;
    }

    initGrid() {
        let gridWidth, gridHeight;
        if (this.mode === 2) {
            gridWidth = kitchen[0].length, gridHeight = kitchen.length;
            for (var y = 0; y < gridHeight; y++) {
                var newRow = [];
                for (var x = 0; x < gridWidth; x++) {
                    // each cell in our grid holds an object to define its color, whether it is solid, and pathing info, including pointers to the next cell that will bring us closer to the optimal path to
                    // the desired end point of the maze
                    // we assume at the beginning that we don't know how far it is to get to the end (-1)
                    // and we default these pointers to "unknown"
                    newRow.push({ solid: (isSolidKitchen(kitchen[y][x]) || isSolidKitchen(overlayKitchen[y][x])) ? true : false, stepsToEnd: -1, nextX: "unknown", nextY: "unknown", nextDirection: -1 });
                }
                this.grid.push(newRow);
            }
        } else {
            gridWidth = world[0].length, gridHeight = world.length;
            for (var y = 0; y < gridHeight; y++) {
                var newRow = [];
                for (var x = 0; x < gridWidth; x++) {
                    // each cell in our grid holds an object to define its color, whether it is solid, and pathing info, including pointers to the next cell that will bring us closer to the optimal path to
                    // the desired end point of the maze
                    // we assume at the beginning that we don't know how far it is to get to the end (-1)
                    // and we default these pointers to "unknown"
                    newRow.push({ solid: isSolid(world[y][x]) || isSolid(overlay[y][x]), stepsToEnd: -1, nextX: "unknown", nextY: "unknown", nextDirection: -1 });
                }
                this.grid.push(newRow);
            }
        }
    }

    recomputePath() {
        let pathTileSize;
        // compute new node value
        if (this.mode === 2) {
            pathTileSize = kitchenTileSize;
        } else {
            pathTileSize = worldTileSize;
        }

        this.nodeX = int(this.x / pathTileSize);
        this.nodeY = int(this.y / pathTileSize);

        // add this to our node history
        this.nodeHistory.push([this.nodeX, this.nodeY]);

        // make sure we aren't stuck in a solid tile!
        if (this.grid[this.nodeY][this.nodeX].solid) {

            // find the most recently visited node that is not solid and move back there
            for (var i = this.nodeHistory.length - 1; i >= 0; i--) {
                if (grid[this.nodeHistory[i][0]][this.nodeHistory[i][1]].solid === false) {
                    // move back to this previous node
                    this.desiredX = this.nodeHistory[i][0] * pathTileSize + pathTileSize / 2;
                    this.desiredY = this.nodeHistory[i][1] * pathTileSize + pathTileSize / 2;
                    break;
                }
            }

            console.log("STUCK!");
        }
        else {
            // compute new desired value
            this.desiredX = this.grid[this.nodeY][this.nodeX].nextX * pathTileSize + pathTileSize / 2;
            this.desiredY = this.grid[this.nodeY][this.nodeX].nextY * pathTileSize + pathTileSize / 2;
        }
    }

    isAtEnd() {
        let pathTileSize;
        if (this.mode === 2) {
            pathTileSize = kitchenTileSize;
        } else {
            pathTileSize = worldTileSize;
        }
        if (dist(this.x / pathTileSize, this.y / pathTileSize, this.destX, this.destY) <= 1) {
            this.x = this.destX * pathTileSize + pathTileSize / 2;
            this.y = this.destY * pathTileSize + pathTileSize / 2;
            return true;
        }

        return false;
    }

    newDest() {
        let pathTileSize;
        // compute new node value
        if (this.mode === 2) {
            pathTileSize = kitchenTileSize;
        } else {
            pathTileSize = worldTileSize;
        }

        this.nodeHistory = [];
        this.walking = false;

        this.nodeX = int(this.x / pathTileSize);
        this.nodeY = int(this.y / pathTileSize);
        this.nodeHistory.push([this.nodeX, this.nodeY]);

        let to = worldNotSolid[floor(random(worldNotSolid.length))];
        this.destX = to[0], this.destY = to[1];

        this.findPaths(this.nodeX, this.nodeY, this.destX, this.destY);
        this.desiredX = this.grid[this.nodeY][this.nodeX].nextX * pathTileSize + pathTileSize / 2;
        this.desiredY = this.grid[this.nodeY][this.nodeX].nextY * pathTileSize + pathTileSize / 2;
    }

    goHome() {
        let pathTileSize;
        // compute new node value
        if (this.mode === 2) {
            pathTileSize = kitchenTileSize;
        } else {
            pathTileSize = worldTileSize;
        }

        this.nodeHistory = [];
        this.walking = false;

        this.nodeX = int(this.x / pathTileSize);
        this.nodeY = int(this.y / pathTileSize);
        this.nodeHistory.push([this.nodeX, this.nodeY]);

        this.destX = 12, this.destY = 7;

        this.findPaths(this.nodeX, this.nodeY, this.destX, this.destY);
        this.desiredX = this.grid[this.nodeY][this.nodeX].nextX * pathTileSize + pathTileSize / 2;
        this.desiredY = this.grid[this.nodeY][this.nodeX].nextY * pathTileSize + pathTileSize / 2;
    }

    // If the player presses `enter` in front of the npc
    // make the npc look at the player (uses slope logic)
    lookAtPlayer(screenX, screenY) {
        let realX = screenX - offsetX;
        let realY = screenY - offsetY;
        if (dist(realX, realY, this.x, this.y) > (this.npcInfo.tileSizeX / 2 + player.tileSize / 2)) {
            return;
        }
        let slope;
        if (realX < this.x) {
            slope = (this.y - realY) / (this.x - realX);
        } else {
            slope = (realY - this.y) / (realX - this.x);
        }
        if (slope > 0) {
            if (slope < 1) {
                if (this.x > realX) {
                    // left
                    this.direction = 1;
                } else {
                    // right
                    this.direction = 2;
                }
            } else {
                if (this.y > realY) {
                    // up
                    this.direction = 3;
                } else {
                    // down
                    this.direction = 0;
                }
            }
        } else {
            if (slope > -1) {
                if (this.x > realX) {
                    // left
                    this.direction = 1;
                } else {
                    // right
                    this.direction = 2;
                }
            } else {
                if (this.y > realY) {
                    // up
                    this.direction = 3;
                } else {
                    // down
                    this.direction = 0;
                }
            }
        }
        this.spritePos = 0;
        this.currentFrames = 0;
        this.walkingTimer = 0;
        this.restingTimer = 0;
        this.walking = false;
        if (this.emoteCoolDown <= 0) {
            this.emoteTimer = 0;
            this.emoting = true;
            // have happy emotes be more likely
            if (random(3) > 1) {
                this.emote = floor(random(7));
                villager_voice1.play();
            } else {
                this.emote = floor(random(emotes.length));
                villager_voice2.play();
            }
            this.emoteCoolDown = this.maxEmoteCoolDown;
            bubblePop.play();
        }
    }

    takeOrder(screenX, screenY, order) {
        let realX = screenX - kitchenOffsetX;
        let realY = screenY - kitchenOffsetY;
        if (dist(realX, realY, this.x, this.y) > kitchenTileSize) {
            return false;
        }
        let slope;
        if (realX < this.x) {
            slope = (this.y - realY) / (this.x - realX);
        } else {
            slope = (realY - this.y) / (realX - this.x);
        }
        if (slope > 0) {
            if (slope < 1) {
                if (this.x > realX) {
                    // left
                    this.direction = 1;
                } else {
                    // right
                    this.direction = 2;
                }
            } else {
                if (this.y > realY) {
                    // up
                    this.direction = 3;
                } else {
                    // down
                    this.direction = 0;
                }
            }
        } else {
            if (slope > -1) {
                if (this.x > realX) {
                    // left
                    this.direction = 1;
                } else {
                    // right
                    this.direction = 2;
                }
            } else {
                if (this.y > realY) {
                    // up
                    this.direction = 3;
                } else {
                    // down
                    this.direction = 0;
                }
            }
        }
        if (this.emoteCoolDown <= 0) {
            this.emoteTimer = 0;
            this.emoting = true;
            this.emoteCoolDown = this.maxEmoteCoolDown;
            bubblePop.play();
        }

        if (player.holding) {
            if (order !== this.order) {
                this.emote = floor(random(7, emotes.length));
                villager_no.play();
                // bad_food.play();
            } else {
                this.emote = floor(random(7));
                this.ordering = false;
                villager_happy.play();
                // good_food.play();
                return true;
            }
        } else {
            this.emote = floor(random(7));
        }
        return false;
    }


    // there are no player at the place the npc is trying to move
    noPlayer(realX, realY) {
        if (stage === 1
            && dist(realX, realY, player.x - offsetX, player.y - offsetY)
            <= player.tileSize / 2 + this.npcInfo.tileSizeX / 2) {
            return false;
        }
        else if (stage === 3
            && dist(realX, realY, player.x - kitchenOffsetX, player.y - kitchenOffsetY)
            <= player.tileSize / 2 + this.npcInfo.tileSizeX / 2) {
            return false;
        }
        return true;
    }

    move() {
        // move based on current movement vector
        if (!(this.desiredX && this.desiredY)) {
            // console.log("NOT MOVING");
            this.newDest();
            this.walking = true;
        }
        if (this.x < this.desiredX) {
            if (this.noPlayer(this.x + this.npcInfo.tileSizeX / 2, this.y)) {
                this.x += 1;
            }
            // look right
            this.direction = 2;
        }
        else if (this.x > this.desiredX) {
            if (this.noPlayer(this.x - this.npcInfo.tileSizeX / 2, this.y)) {
                this.x -= 1;
            }
            // look left
            this.direction = 1;
        }
        else if (this.y < this.desiredY) {
            if (this.noPlayer(this.x, this.y + this.npcInfo.tileSizeY / 2)) {
                this.y += 1;
            }
            // look down
            this.direction = 0;
        }
        else if (this.y > this.desiredY) {
            if (this.noPlayer(this.x, this.y - this.npcInfo.tileSizeY / 2)) {
                this.y -= 1;
            }
            // look up
            this.direction = 3;
        } else {
            // console.log("NOT MOVING");
            this.newDest();
            this.walking = true;
        }

        // have we reached our new position?  if so, compute a new node value
        if (dist(this.x, this.y, this.desiredX, this.desiredY) < 2) {
            // snap to our desired position
            this.x = this.desiredX;
            this.y = this.desiredY;

            // note this position
            this.nodeHistory.push([this.nodeX, this.nodeY]);

            // see where we need to go next!
            this.recomputePath();
        }
    }

    // NPC walking animation
    display() {
        imageMode(CENTER);
        let progression = [1, 0, 1, 2];
        if (this.charID === 1 && this.direction === 3) {
            progression = [1, 0];
        }

        // draw image
        drawTile(nPCs[this.charID], (this.direction * this.npcInfo.tilesPerRow) + progression[this.spritePos],
            this.npcInfo.tileSizeX, this.npcInfo.tileSizeY,
            this.x + offsetX, this.y + offsetY,
            this.npcInfo.tileSizeX, this.npcInfo.tileSizeY,);

        // the NPC is walking
        if (this.walking) {
            if (this.currentFrames >= this.maxFrames) {
                if (this.spritePos + 1 < progression.length) {
                    this.spritePos++;
                } else {
                    this.spritePos = 0;
                }
                this.currentFrames = 0;
            }
            this.currentFrames++;
        } else {
            this.spritePos = 0;
            if (this.idleTimer < this.maxIdleTimer) {
                this.idleTimer++;
                if (floor(random(100)) < 1) {
                    this.direction = floor(random(4));
                }
            } else {
                this.walking = true;
                this.idleTimer = 0;
            }
        }
        imageMode(CORNER);
    }

    // NPC walking animation
    displayKitchen() {
        imageMode(CENTER);
        let progression = [1, 0, 1, 2];
        if (this.charID === 1 && this.direction === 3) {
            progression = [1, 0];
        }

        // draw image
        drawTile(nPCs[this.charID], (this.direction * this.npcInfo.tilesPerRow) + progression[this.spritePos],
            this.npcInfo.tileSizeX, this.npcInfo.tileSizeY,
            this.x + kitchenOffsetX, this.y + kitchenOffsetY,
            this.npcInfo.tileSizeX * kitchenTileSize / 32, this.npcInfo.tileSizeY * kitchenTileSize / 32,);

        // the NPC is walking
        if (this.walking) {
            if (this.currentFrames >= this.maxFrames) {
                if (this.spritePos + 1 < progression.length) {
                    this.spritePos++;
                } else {
                    this.spritePos = 0;
                }
                this.currentFrames = 0;
            }
            this.currentFrames++;
        } else if (this.ordering) {
            if (!this.emoting) {
                this.spritePos = 0;
                this.direction = this.chair + 1;
                let img = pot.recipeBook[this.order].bubble;
                drawTile(img, 0, img.width, img.height, this.x + kitchenOffsetX + kitchenTileSize / 4,
                    this.y + kitchenOffsetY - kitchenTileSize / 4, kitchenTileSize * 1.5, kitchenTileSize * 2.25);
            }
        } else {
            this.spritePos = 0;
            this.direction = this.chair + 1;
            if (this.idleTimer < this.maxIdleTimer) {
                this.idleTimer++;
                showFood(this.table, this.order);
            } else {
                this.walking = true;
                this.idleTimer = 0;
                this.order = -1;
            }
        }
        imageMode(CORNER);
    }

    displayEmote() {
        let x, y, size;
        if (this.mode === 2) {
            x = this.x + kitchenOffsetX + kitchenTileSize / 2;
            y = this.y + kitchenOffsetY - kitchenTileSize / 3;
            size = 60;
        } else {
            x = this.x + offsetX + this.npcInfo.tileSizeX / 2;
            y = this.y + offsetY - this.npcInfo.tileSizeY / 3;
            size = 27;
        }
        imageMode(CENTER);
        if (this.emoting) {
            image(emotes[this.emote], x, y, size, size);
            if (this.emoteTimer < this.maxEmoteTimer) {
                this.emoteTimer++;
            } else {
                this.emoteTimer = 0;
                this.emoting = false;
            }
        }
        if (this.emoteCoolDown >= 0) {
            this.emoteCoolDown--;
        }
        imageMode(CORNER);
    }
}

class Pot {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.cooking = 0;
        this.insidePotArr = [];
        this.noiseLocationX = random(1000);
        this.size = kitchenTileSize * (1.2);
        this.recipe = -1;
        this.recipeBook = [
            {
                inPot: eggsalad,
                plate: eggsalad_plate,
                bubble: eggsalad_bubble,
                menu: eggsalad_menu,
                recipe: [3, 5, 7]
            },
            {
                inPot: bruschetta,
                plate: bruschetta_plate,
                bubble: bruschetta_bubble,
                menu: bruschetta_menu,
                recipe: [3, 4]
            },
            {
                inPot: cheesybread,
                plate: cheesybread_plate,
                bubble: cheesybread_bubble,
                menu: cheesybread_menu,
                recipe: [4, 6]
            }
        ];
        this.cookingTimer = 0;
        this.maxCookingTImer = 240;
    }

    change(x, y) {
        this.x = x;
        this.y = y;
    }

    isInBook() {
        for (let i = 0; i < this.recipeBook.length; i++) {
            let recipeObj = this.recipeBook[i].recipe;
            for (let n = 0; n < recipeObj.length; n++) {
                if (this.insidePotArr.includes(recipeObj[n])) {
                    if (n === recipeObj.length - 1) {
                        return i;
                    }
                } else {
                    break;
                }
            }
        }
        return -1;
    }

    startCooking() {
        this.recipe = this.isInBook();
        if (this.recipe >= 0) {
            this.cooking = 1;
            for (let n = 0; n < this.insidePotArr.length; n++) {
                let index = this.insidePotArr[n];
                inventoryArray[index].amount--;
            }
            this.insidePotArr = [];
            cookingSound.play();
        }
        potPopUp = false;
    }

    display() {
        if (this.cooking === 0) {
            drawTile(pot_empty, 0, pot_empty.width, pot_empty.height, this.x, this.y, this.size, this.size);
        } else if (this.cooking === 1) {
            let xOffset = map(noise(this.noiseLocationX), 0, 1, -1, 1);
            drawTile(pot_full, 0, pot_full.width, pot_full.height, this.x + xOffset, this.y, this.size, this.size);
            this.noiseLocationX += 0.1;
            this.cookingTimer++;
            if (this.cookingTimer >= this.maxCookingTImer) {
                this.cooking = 2;
                this.cookingTimer = 0;
                cookingSound.stop();
                ding.play();
            }
        } else if (this.cooking === 2) {
            let img = this.recipeBook[this.recipe].inPot;
            drawTile(pot_full, 0, pot_full.width, pot_full.height, this.x, this.y, this.size, this.size);
            drawTile(img, 0, img.width, img.height, this.x + kitchenTileSize / 6, this.y + kitchenTileSize / 5, this.size / 1.5, this.size / 2);
        }
    }
}
